<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beliefs Explained</title> <!-- Updated Title -->

    <style>
        /* Basic Reset and Global Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: sans-serif;
            line-height: 1.6;
            background-color: #f4f4f4;
            /* Default light mode background */
            color: #333;
            /* Default light mode text */
            transition: background-color 0.3s ease, color 0.3s ease;
            height: 100vh;
            overflow: hidden;
            /* Hide scrollbar on body, views manage their own overflow */
            display: flex;
            /* Use flex to easily center/manage content */
            justify-content: center;
            align-items: center;
        }

        /* --- Layout and Views --- */

        /* Container for global controls (theme button) */
        .global-controls {
            position: fixed;
            /* Position them globally */
            top: 10px;
            right: 10px;
            z-index: 1001;
            /* Ensure they are above other content */
            display: flex;
            gap: 10px;
            /* Space between buttons */
        }

        /* Main app content wrapper - now always visible and centered */
        #main-app-content {
            width: 100%;
            height: 100%;
            max-width: 800px;
            /* Example max width */
            margin: 0 auto;
            /* Center the main content */
            background-color: #fff;
            /* Content background */
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            display: flex;
            /* Use flex to manage views */
            flex-direction: column;
        }

        /* General styling for view containers */
        .view {
            flex-grow: 1;
            /* Allow views to fill space */
            padding: 20px;
            overflow-y: auto;
            /* Add scrolling to individual views */
            display: none;
            /* Hidden by default, JS manages display */
            flex-direction: column;
            /* Default direction for views */
        }

        /* Utility class for hiding elements visually and for screen readers */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }

        /* Utility class for hiding elements completely */
        .hidden {
            display: none !important;
        }


        /* --- Representative Selection View Styles --- */
        /* Renamed ID */
        #representative-selection {
            display: flex;
            /* Default display for this view when shown by JS */
            flex-direction: column;
        }

        /* Renamed ID */
        #representative-filters {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
            display: flex;
            flex-wrap: wrap;
            /* Allow filters to wrap */
            gap: 10px;
            /* Space between filter groups and search/manage */
            align-items: center;
            /* Vertically align items */
        }

        #representative-filters .filter-options {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            /* Space between individual checkboxes/labels */
            /* Optional: Add a background or border to the filter group */
        }

        #representative-filters input[type="checkbox"] {
            display: none;
            /* Hide the actual checkbox */
        }

        /* Style the label like a button or pill */
        #representative-filters label {
            display: inline-block;
            padding: 5px 10px;
            border: 1px solid #ccc;
            border-radius: 15px;
            /* Pill shape */
            cursor: pointer;
            background-color: #f8f9fa;
            font-size: 0.9em;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }

        #representative-filters label:hover {
            background-color: #e2e6ea;
        }

        /* Style the label when the checkbox is checked */
        #representative-filters input[type="checkbox"]:checked+label,
        #representative-filters label[aria-selected="true"] {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }

        /* Renamed ID */
        #representative-search {
            padding: 8px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            flex-grow: 1;
            /* Allow search input to take available space */
            min-width: 150px;
            /* Ensure it doesn't get too small */
        }

        /* Renamed ID */
        #manage-representatives-button {
            padding: 8px 15px;
            background-color: #28a745;
            /* Example: Green color */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            white-space: nowrap;
            /* Prevent text wrapping */
        }

        #manage-representatives-button:hover {
            background-color: #218838;
        }

        /* Renamed ID */
        #representative-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            /* Responsive grid */
            gap: 15px;
            /* Space between cards */
            padding-top: 15px;
            /* Space from filter/search */
        }

        /* Renamed class names */
        .representative-card {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
            display: flex;
            /* Use flex for internal layout */
            flex-direction: column;
            justify-content: space-between;
            /* Push tags to bottom if needed */
            align-items: center;
            /* Center content horizontally */
            min-height: 120px;
            /* Give cards a minimum height */
        }

        .representative-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
            background-color: #e9e9e9;
        }

        .representative-card h3 {
            font-size: 1.1em;
            margin-bottom: 10px;
        }

        .representative-tags {
            margin-top: auto;
            /* Push tags to the bottom */
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
            font-size: 0.8em;
        }

        .representative-tags .tag {
            background-color: #e0e0e0;
            padding: 3px 8px;
            border-radius: 10px;
        }

        .empty-grid-message {
            text-align: center;
            grid-column: 1 / -1;
            /* Center across all columns */
            color: #666;
            margin-top: 20px;
        }


        /* --- Chat Container Styles --- */
        #chat-container {
            display: flex;
            /* Default display for this view when shown by JS */
            flex-direction: column;
        }

        #chat-header {
            display: flex;
            align-items: center;
            padding: 10px 20px;
            border-bottom: 1px solid #eee;
            background-color: #f8f9fa;
            /* Header background */
        }

        #chat-header h3 {
            flex-grow: 1;
            /* Push buttons to the sides */
            text-align: center;
            font-size: 1.1em;
        }

        /* Updated ID */
        #chat-header h3 span#current-representative {
            /* Add specific styles if needed for the figure name */
            font-weight: bold;
        }


        #chat-header .icon-button {
            font-size: 1.2em;
            padding: 5px;
        }

        #chatbox {
            flex-grow: 1;
            /* Allow chatbox to fill available space */
            padding: 10px 20px;
            overflow-y: auto;
            /* Enable scrolling for messages */
            display: flex;
            flex-direction: column;
            gap: 10px;
            /* Space between messages */
            background-color: #fff;
            /* Chat background */
        }

        .message {
            max-width: 80%;
            /* Limit message width */
            padding: 10px;
            border-radius: 8px;
            word-wrap: break-word;
            /* Break long words */
            line-height: 1.5;
        }

        .user-message {
            align-self: flex-end;
            /* Align user messages to the right */
            background-color: #007bff;
            /* User message color */
            color: white;
            border-bottom-right-radius: 0;
            /* Style the bubble corner */
        }

        .bot-message {
            align-self: flex-start;
            /* Align bot messages to the left */
            background-color: #e9ecef;
            /* Bot message color */
            color: #333;
            border-bottom-left-radius: 0;
            /* Style the bubble corner */
        }

        .bot-message.initial-message {
            background-color: #d4edda;
            /* Different color for initial messages */
            color: #155724;
            font-style: italic;
        }

        /* Typing indicator animation */
        .bot-message.typing {
            background-color: #e0e0e0;
            color: #666;
            font-style: italic;
        }

        .bot-message.typing .dot {
            animation: blink 1s infinite steps(1);
        }

        .bot-message.typing .dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .bot-message.typing .dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes blink {
            0% {
                opacity: 0.2;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.2;
            }
        }


        #chat-input-area {
            display: flex;
            padding: 10px 20px;
            border-top: 1px solid #eee;
            background-color: #f8f9fa;
            /* Footer background */
        }

        #user-input {
            flex-grow: 1;
            /* Allow input to take space */
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-right: 10px;
            resize: none;
            /* Prevent manual resize */
            overflow-y: auto;
            /* Add scrollbar if text exceeds height */
            max-height: 100px;
            /* Limit max height to avoid giant input box */
        }

        #user-input:disabled {
            background-color: #e9ecef;
            cursor: not-allowed;
        }


        #send-button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        #send-button:hover:not(:disabled) {
            background-color: #0056b3;
        }

        #send-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* --- Representative Management View Styles --- */
        /* Renamed ID */
        #representative-management {
            display: flex;
            /* Default display for this view when shown by JS */
            flex-direction: column;
        }

        #representative-management .controls {
            display: flex;
            justify-content: space-between;
            /* Space out the buttons */
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        #representative-management .controls button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
        }

        /* Renamed ID */
        #add-representative-button {
            background-color: #007bff;
            color: white;
        }

        #add-representative-button:hover {
            background-color: #0056b3;
        }

        /* Renamed ID */
        #back-from-management-button {
            background-color: #6c757d;
            color: white;
        }

        #back-from-management-button:hover {
            background-color: #5a6268;
        }

        /* Renamed ID */
        #representative-management-list {
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            flex-grow: 1;
            /* Allow list to fill vertical space */
            overflow-y: auto;
            /* Scroll the list if it exceeds container height */
        }

        /* Renamed class names */
        .management-representative-item {
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 10px;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
            gap: 8px;
            /* Space between elements */
        }

        .management-representative-item:last-child {
            margin-bottom: 0;
            /* No bottom margin for the last item */
        }

        .management-representative-item h4 {
            font-size: 1.1em;
            border-bottom: 1px dashed #eee;
            padding-bottom: 5px;
            margin-bottom: 5px;
        }

        .management-representative-item p {
            font-size: 0.9em;
            color: #555;
        }

        .management-representative-item strong {
            color: #333;
        }

        .management-representative-item .instruction-preview {
            font-style: italic;
            color: #666;
            white-space: nowrap;
            /* Keep on one line */
            overflow: hidden;
            /* Hide overflow */
            text-overflow: ellipsis;
            /* Add ellipsis for overflow */
        }

        .item-actions {
            display: flex;
            justify-content: flex-end;
            /* Align buttons to the right */
            gap: 10px;
            /* Space between buttons */
            margin-top: 10px;
            /* Space from content above */
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        /* Renamed class names */
        .item-actions button {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .edit-representative-button {
            background-color: #ffc107;
            /* Example: Yellow for edit */
            color: #212529;
        }

        .edit-representative-button:hover {
            background-color: #e0a800;
        }

        .delete-representative-button {
            background-color: #dc3545;
            /* Example: Red for delete */
            color: white;
        }

        .delete-representative-button:hover {
            background-color: #c82333;
        }

        .empty-list-message {
            text-align: center;
            color: #666;
            padding: 20px;
        }


        /* --- Representative Form Modal Styles --- */
        /* Renamed ID */
        #representative-form-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            /* Darker, slightly transparent background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1010;
            /* Ensure it's above everything else */
            /* Hidden by default via .hidden class */
        }

        #representative-form-modal .modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            max-width: 500px;
            /* Limit modal width */
            width: 90%;
            /* Responsive width */
            max-height: 90vh;
            /* Limit modal height */
            overflow-y: auto;
            /* Add scroll if form content exceeds height */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        /* Renamed ID */
        #representative-form-title {
            margin-top: 0;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.3em;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        /* Renamed ID */
        #representative-form {
            display: flex;
            flex-direction: column;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            /* Label on its own line */
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.95em;
        }

        .form-group input[type="text"],
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
            resize: vertical;
            /* Allow vertical resize for textarea */
        }

        .form-group input[type="text"]:focus,
        .form-group textarea:focus {
            border-color: #007bff;
            outline: none;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        }

        .form-actions {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
            display: flex;
            justify-content: flex-end;
            /* Align buttons to the right */
            gap: 10px;
            /* Space between buttons */
        }

        .form-actions button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
        }

        .form-actions button[type="submit"] {
            background-color: #007bff;
            color: white;
        }

        .form-actions button[type="submit"]:hover {
            background-color: #0056b3;
        }

        /* Renamed ID */
        #cancel-form-button {
            background-color: #6c757d;
            color: white;
        }

        #cancel-form-button:hover {
            background-color: #5a6268;
        }


        /* --- Icon Button Base Style --- */
        .icon-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            font-size: 1em;
            transition: opacity 0.2s ease;
        }

        .icon-button:hover {
            opacity: 0.7;
        }

        /* Theme Toggle specific icon styles */
        .theme-toggle .sun-icon {
            display: inline-block;
        }

        .theme-toggle .moon-icon {
            display: none;
            /* Moon icon hidden by default */
        }

        /* --- Dark Mode Styles --- */
        body.dark-mode {
            background-color: #1e1e1e;
            color: #e0e0e0;
        }

        body.dark-mode #main-app-content {
            background-color: #2b2b2b;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        body.dark-mode #chat-header,
        body.dark-mode #chat-input-area,
        body.dark-mode #representative-management .controls {
            /* Renamed ID */
            background-color: #3c3c3c;
            border-color: #555;
        }

        body.dark-mode #chat-header {
            color: #e0e0e0;
        }


        body.dark-mode #representative-filters {
            /* Renamed ID */
            border-color: #555;
        }

        body.dark-mode #representative-filters label {
            /* Renamed ID */
            border-color: #555;
            background-color: #3c3c3c;
            color: #e0e0e0;
        }

        body.dark-mode #representative-filters label:hover {
            /* Renamed ID */
            background-color: #505050;
        }

        body.dark-mode #representative-filters input[type="checkbox"]:checked+label,
        /* Renamed ID */
        body.dark-mode #representative-filters label[aria-selected="true"] {
            /* Renamed ID */
            background-color: #007bff;
            /* Keep bright accent */
            color: white;
            border-color: #007bff;
        }

        body.dark-mode #representative-search {
            /* Renamed ID */
            border-color: #555;
            background-color: #3c3c3c;
            color: #e0e0e0;
        }

        body.dark-mode #representative-search::placeholder {
            /* Renamed ID */
            color: #bbb;
        }


        body.dark-mode #manage-representatives-button {
            /* Renamed ID */
            background-color: #218838;
            /* Darker green in dark mode */
        }

        body.dark-mode #manage-representatives-button:hover {
            /* Renamed ID */
            background-color: #1e7e34;
        }


        body.dark-mode .representative-card {
            /* Renamed class */
            background-color: #3c3c3c;
            border-color: #555;
            color: #e0e0e0;
        }

        body.dark-mode .representative-card:hover {
            /* Renamed class */
            transform: translateY(-5px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);
            background-color: #505050;
        }

        body.dark-mode .representative-tags .tag {
            /* Renamed class */
            background-color: #555;
            color: #e0e0e0;
        }

        body.dark-mode .empty-grid-message,
        body.dark-mode .empty-list-message {
            color: #aaa;
        }


        body.dark-mode #chatbox {
            background-color: #2b2b2b;
        }

        body.dark-mode .bot-message {
            background-color: #3c3c3c;
            color: #e0e0e0;
        }

        body.dark-mode .bot-message.initial-message {
            background-color: #1e4c2b;
            /* Darker green */
            color: #a3e0b7;
        }

        body.dark-mode .bot-message.typing {
            background-color: #555;
            color: #ccc;
        }


        body.dark-mode #user-input {
            border-color: #555;
            background-color: #3c3c3c;
            color: #e0e0e0;
        }

        body.dark-mode #user-input:disabled {
            background-color: #555;
            color: #aaa;
        }

        body.dark-mode #user-input::placeholder {
            color: #bbb;
        }


        body.dark-mode .theme-toggle .sun-icon {
            display: none;
            /* Sun icon hidden in dark mode */
        }

        body.dark-mode .theme-toggle .moon-icon {
            display: inline-block;
            /* Moon icon visible in dark mode */
        }


        /* Dark mode for Representative Management */
        /* Renamed ID */
        body.dark-mode #representative-management-list {
            border-color: #555;
        }

        /* Renamed class */
        body.dark-mode .management-representative-item {
            border-color: #555;
            background-color: #3c3c3c;
            color: #e0e0e0;
        }

        body.dark-mode .management-representative-item:hover {
            background-color: #505050;
            /* Slight hover effect */
        }

        body.dark-mode .management-representative-item h4 {
            border-color: #555;
        }

        body.dark-mode .management-representative-item p {
            color: #bbb;
        }

        body.dark-mode .management-representative-item strong {
            color: #e0e0e0;
        }

        body.dark-mode .management-representative-item .instruction-preview {
            color: #aaa;
        }

        body.dark-mode .item-actions {
            border-color: #555;
        }

        /* Renamed class */
        body.dark-mode .edit-representative-button {
            background-color: #d39e00;
            /* Darker yellow in dark mode */
            color: #212529;
        }

        body.dark-mode .edit-representative-button:hover {
            background-color: #c69500;
        }

        /* Renamed class */
        body.dark-mode .delete-representative-button {
            background-color: #dc3545;
            /* Example: Red for delete */
            color: white;
        }

        body.dark-mode .delete-representative-button:hover {
            background-color: #bd2330;
        }


        /* Dark mode for Representative Form Modal */
        /* Renamed ID */
        body.dark-mode #representative-form-modal .modal-content {
            background-color: #2b2b2b;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            color: #e0e0e0;
        }

        /* Renamed ID */
        body.dark-mode #representative-form-title {
            border-color: #555;
            color: #e0e0e0;
        }

        body.dark-mode .form-group label {
            color: #e0e0e0;
        }

        body.dark-mode .form-group input[type="text"],
        body.dark-mode .form-group textarea {
            border-color: #555;
            background-color: #3c3c3c;
            color: #e0e0e0;
        }

        body.dark-mode .form-group input[type="text"]::placeholder,
        body.dark-mode .form-group textarea::placeholder {
            color: #bbb;
        }


        body.dark-mode .form-group input[type="text"]:focus,
        body.dark-mode .form-group textarea:focus {
            border-color: #007bff;
            /* Keep accent */
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.5);
        }

        body.dark-mode .form-actions {
            border-color: #555;
        }

        body.dark-mode .form-actions button[type="submit"] {
            background-color: #0056b3;
            /* Darker blue */
        }

        body.dark-mode .form-actions button[type="submit"]:hover {
            background-color: #004085;
        }

        /* Renamed ID */
        body.dark-mode #cancel-form-button {
            background-color: #5a6268;
            /* Darker grey */
        }

        body.dark-mode #cancel-form-button:hover {
            background-color: #495057;
        }
    </style>
</head>

<body class="light-mode">

    <!-- Global Controls (positioned via CSS) -->
    <div class="global-controls" role="group" aria-label="Global Controls">
        <button id="dark-mode-toggle" class="icon-button theme-toggle" aria-label="Toggle Dark Mode">
            <span class="sun-icon">☀️</span>
            <span class="moon-icon">🌙</span>
        </button>
    </div>

    <!-- Main App Content Wrapper -->
    <div id="main-app-content">

        <!-- Representative Selection View -->
        <!-- Initially hidden (handled by .view.hidden) - JS will show the correct view on load -->
        <div id="representative-selection" class="view hidden" aria-hidden="true"> <!-- Renamed ID -->
            <h2>Select a Representative</h2> <!-- Updated Heading -->
            <p>Explore different perspectives on beliefs and philosophies.</p> <!-- Added description -->

            <div id="representative-filters"> <!-- Renamed ID -->
                <div class="filter-options" role="group" aria-label="Belief System Filters"> <!-- Updated Label -->
                    <!-- Filter checkboxes - Updated labels and values for beliefs -->
                    <input type="checkbox" id="filter-all" name="representative-filter" value="all">
                    <label for="filter-all" role="option">All</label>

                    <!-- Add more filter checkboxes here based on your desired categories -->
                    <!-- Example Filter Suggestions (adjust values/labels as needed): -->
                    <input type="checkbox" id="filter-religion-islam" name="representative-filter"
                        value="religion-islam"><label for="filter-religion-islam" role="option">Religion: Islam</label>
                    <input type="checkbox" id="filter-religion-christianity" name="representative-filter"
                        value="religion-christianity"><label for="filter-religion-christianity" role="option">Religion:
                        Christianity</label>
                    <!-- Add other major religions if applicable (e.g., Judaism, Buddhism, Hinduism) -->

                    <input type="checkbox" id="filter-sect-sunni" name="representative-filter" value="sect-sunni"><label
                        for="filter-sect-sunni" role="option">Sect: Sunni</label>
                    <input type="checkbox" id="filter-sect-shia" name="representative-filter" value="sect-shia"><label
                        for="filter-sect-shia" role="option">Sect: Shia</label>
                    <!-- Add other Islamic sects/branches -->

                    <input type="checkbox" id="filter-denomination-orthodox" name="representative-filter"
                        value="denomination-orthodox"><label for="filter-denomination-orthodox"
                        role="option">Denomination: Orthodox</label>
                    <input type="checkbox" id="filter-denomination-catholic" name="representative-filter"
                        value="denomination-catholic"><label for="filter-denomination-catholic"
                        role="option">Denomination: Catholic</label>
                    <input type="checkbox" id="filter-denomination-protestant" name="representative-filter"
                        value="denomination-protestant"><label for="filter-denomination-protestant"
                        role="option">Denomination: Protestant</label>
                    <!-- Add other Christian denominations -->

                    <input type="checkbox" id="filter-philosophical-atheism" name="representative-filter"
                        value="philosophical-atheism"><label for="filter-philosophical-atheism"
                        role="option">Philosophical: Atheism</label>
                    <input type="checkbox" id="filter-philosophical-agnosticism" name="representative-filter"
                        value="philosophical-agnosticism"><label for="filter-philosophical-agnosticism"
                        role="option">Philosophical: Agnosticism</label>
                    <!-- Add other philosophical stances -->


                    <input type="checkbox" id="filter-movement-sufism" name="representative-filter"
                        value="movement-sufism"><label for="filter-movement-sufism" role="option">Movement:
                        Sufism</label>
                    <input type="checkbox" id="filter-school-ashari" name="representative-filter"
                        value="school-ashari"><label for="filter-school-ashari" role="option">School: Ash'ari</label>
                    <input type="checkbox" id="filter-school-hanbali" name="representative-filter"
                        value="school-hanbali"><label for="filter-school-hanbali" role="option">School: Hanbali</label>
                    <input type="checkbox" id="filter-school-shafii" name="representative-filter"
                        value="school-shafii"><label for="filter-school-shafii" role="option">School: Shafi'i</label>
                    <input type="checkbox" id="filter-school-zahiri" name="representative-filter"
                        value="school-zahiri"><label for="filter-school-zahiri" role="option">School: Zahiri</label>
                    <input type="checkbox" id="filter-movement-quranist" name="representative-filter"
                        value="movement-quranist"><label for="filter-movement-quranist" role="option">Movement:
                        Quranist</label>
                    <!-- Add other specific schools or movements -->

                </div>
                <input type="text" id="representative-search" placeholder="Search representatives..."
                    aria-label="Search representatives" autocomplete="off"> <!-- Updated placeholder/label -->
                <!-- Button to go to Representative Management -->
                <button id="manage-representatives-button" aria-label="Manage Representatives">Manage
                    Representatives</button> <!-- Updated Text/Label -->
            </div>

            <div id="representative-grid" role="listbox" aria-label="Select a representative"> <!-- Updated Label -->
                <!-- Representative cards will be rendered here by JavaScript -->
            </div>
            <!-- Optional ARIA status element for screen readers -->
            <div id="grid-status" role="status" aria-live="polite" class="visually-hidden"></div>
        </div>

        <!-- Chat Container View -->
        <!-- Initially hidden (handled by .view.hidden) -->
        <div id="chat-container" class="view hidden" aria-hidden="true">
            <div id="chat-header">
                <button id="back-to-representatives" class="icon-button" aria-label="Back to Representatives">←</button>
                <!-- Updated Label -->
                <h3>Discussing beliefs with: <span id="current-representative"></span></h3> <!-- Updated ID and Text -->
                <button id="clear-chat" class="icon-button" aria-label="Clear Chat History">🗑️</button>
            </div>
            <div id="chatbox" role="log" aria-live="polite" tabindex="0">
                <!-- Chat messages will be appended here by JavaScript -->
            </div>
            <div id="chat-input-area">
                <label for="user-input" class="visually-hidden">Enter your question or comment</label>
                <!-- Updated Label -->
                <textarea id="user-input" placeholder="Ask about their beliefs..." rows="1" disabled
                    aria-disabled="true" autocomplete="off"></textarea> <!-- Updated Placeholder -->
                <button id="send-button" disabled aria-disabled="true">Send</button>
            </div>
        </div>

        <!-- Representative Management View -->
        <!-- Initially hidden (handled by .view.hidden) -->
        <div id="representative-management" class="view hidden" aria-hidden="true"> <!-- Renamed ID -->
            <h2>Manage Representatives</h2> <!-- Updated Heading -->
            <div class="controls">
                <button id="add-representative-button" aria-label="Add New Representative">Add New
                    Representative</button> <!-- Updated Text/Label -->
                <button id="back-from-management-button" aria-label="Back to Representatives">Back</button>
                <!-- Updated Text/Label -->
            </div>

            <div id="representative-management-list"> <!-- Renamed ID -->
                <!-- Representative items for management will be rendered here -->
            </div>

            <!-- Simple Add/Edit Form Modal -->
            <!-- Initially hidden -->
            <div id="representative-form-modal" class="modal hidden" aria-hidden="true" role="dialog" aria-modal="true"
                aria-labelledby="representative-form-title"> <!-- Renamed ID -->
                <div class="modal-content">
                    <h3 id="representative-form-title">Add New Representative</h3> <!-- Updated Title -->
                    <form id="representative-form"> <!-- Renamed ID -->
                        <input type="hidden" id="form-representative-key"> <!-- Renamed ID -->

                        <div class="form-group">
                            <label for="form-representative-name">Name / Label:</label> <!-- Updated Label -->
                            <input type="text" id="form-representative-name" required autocomplete="off">
                            <!-- Renamed ID -->
                        </div>

                        <div class="form-group">
                            <label for="form-representative-instruction">Instruction (Define how they explain their
                                beliefs and worldview):</label> <!-- Updated Label -->
                            <textarea id="form-representative-instruction" rows="5" required
                                autocomplete="off"></textarea> <!-- Renamed ID -->
                        </div>

                        <div class="form-group">
                            <label for="form-representative-types">Types (comma-separated, e.g., religion-islam,
                                sect-sunni, philosophical-atheism):</label> <!-- Updated Label -->
                            <input type="text" id="form-representative-types"
                                placeholder="e.g., religion-islam, sect-sunni" autocomplete="off">
                            <!-- Updated Placeholder -->
                        </div>

                        <div class="form-group">
                            <label for="form-representative-categories">Categories (comma-separated, e.g.,
                                school-ashari, movement-sufism, denomination-orthodox):</label> <!-- Updated Label -->
                            <input type="text" id="form-representative-categories"
                                placeholder="e.g., school-ashari, denomination-catholic" autocomplete="off">
                            <!-- Updated Placeholder -->
                        </div>

                        <div class="form-actions">
                            <button type="submit">Save Representative</button> <!-- Updated Text -->
                            <button type="button" id="cancel-form-button">Cancel</button> <!-- Renamed ID -->
                        </div>
                    </form>
                </div>
            </div>
        </div>

    </div>

    <!-- Optional ARIA live region for general announcements -->
    <div id="aria-live-status" role="status" aria-live="polite" class="visually-hidden"></div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- config.js ---
            // !!! IMPORTANT SECURITY WARNING !!!
            // Placing your API key directly in frontend code is HIGHLY INSECURE.
            // Anyone viewing your page source can steal your key, potentially leading to unexpected charges.
            // Use this ONLY for local development or trusted environments.
            // For production, ALWAYS use a backend server to handle API calls securely.
            // As requested, this risk is acknowledged and this key remains client-side for now.
            // ========================================================

            // --- API Configuration ---
            const GOOGLE_API_KEY = 'AIzaSyDFTC32n3d0HcLWcuq4h91pyLydCLK24sQ'; // <--- REPLACE WITH YOUR ACTUAL KEY
            const API_BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent'; // Using a potentially faster model

            // Global instruction for the AI's role (Explanation focused, NOT Debate/Convince)
            const GLOBAL_INSTRUCTION = `You are an AI assistant roleplaying as a representative explaining a specific belief system, religion, sect, or philosophical stance to a user who is asking questions about it.
            Your primary goal is to clearly and neutrally (from the perspective of the belief system you represent) explain the core tenets, practices, and worldview associated with the specific identity provided in your individual instruction, if user try to convince you that you a wrong try to debit him and convince him you are right not him and why.
            You MUST NOT:
            - Generate any hate speech, discriminatory content, or content that could incite violence.
            - Act as an authority on absolute truth. You are an *explainer* of a specific perspective.
            - Use language that is overly dogmatic or judgmental towards others.
            - Repeat your self and keep telling the user what you are represent, you can introduce your self once.

            Maintain a calm, informative, and respectful tone, regardless of the user's questions or statements. Respond ONLY from the perspective of the belief system assigned in your individual instruction, focusing on clarifying and explaining its tenets. If a question is outside the scope of explaining the belief system, or if it violates safety guidelines, you should decline to answer respectfully.`;


            // Negative instruction to prevent revealing AI identity and enforce safety
            const NEGATIVE_INSTRUCTION = `Absolutely do NOT mention that you are an AI, a bot, a large language model, a machine, a computer program, artificial intelligence, or anything similar. Do not break character or refer to yourself as anything other than a representative explaining the specific belief system assigned to you. Do not express personal opinions or claim consciousness. Strictly adhere to the role of an informational explainer from the given perspective. Do NOT generate responses that are harmful, biased, prejudiced, or promote discrimination or violence against any group or individual based on their beliefs or lack thereof.`;


            // --- Persistence Storage Keys (Updated) ---
            const SESSION_STORAGE_KEY_ACTIVE_REPRESENTATIVE = 'activeRepresentativeKey_beliefsChat';
            const SESSION_STORAGE_KEY_HISTORY = 'conversationHistory_beliefsChat';
            const LOCAL_STORAGE_KEY_STATE = 'beliefsChatAppState'; // General state like filters
            const LOCAL_STORAGE_KEY_THEME = 'theme_beliefsChat';

            // --- Representative Storage Key (Updated) ---
            const LOCAL_STORAGE_KEY_REPRESENTATIVES = 'beliefsChatRepresentatives';


            // --- state.js (Updated) ---
            const appState = {
                // View State
                currentState: 'representative-selection', // Default view when the app starts

                // Representative Data (Mutable)
                allRepresentativesMutable: [], // This will hold the dynamic list

                // Representative Selection State
                selectedFilters: [], // Array of selected filter values (default to ['all'] later)
                currentSearchTerm: '', // Track the current search input value

                // Chat State (Currently only supports one active chat)
                selectedRepresentative: null, // Will store the selected representative object {key, name, instruction, types, categories}
                conversationHistory: [], // Stores messages [{ role: 'user'|'model', parts: [{text: '...'}] }]

                // Add other state properties here as needed...
            };

            // --- representativeData.js (New Data Structure) ---
            // Note: Instructions are crucial here to define the AI's explanatory role within safety constraints.
            // const defaultRepresentatives = [
            //     // --- Islamic Representatives ---
            //     {
            //         key: 'representative-islam-sunni',
            //         name: 'Representative of Sunni Islam',
            //         types: ['religion-islam', 'sect-sunni'],
            //         categories: [], // Specific schools could go here (e.g., school-hanbali, school-ashari)
            //         instruction: "You are an AI roleplaying as a representative who explains the core beliefs and practices of Sunni Islam. Base your explanations on the Quran, Sunnah (Prophetic traditions), and the consensus of classical Sunni scholarship. Explain concepts clearly and respectfully. Do not attempt to persuade or criticize other viewpoints. Focus on clarifying Sunni Islamic teachings."
            //     },
            //     {
            //         key: 'representative-islam-shia',
            //         name: 'Representative of Shia Islam',
            //         types: ['religion-islam', 'sect-shia'],
            //         categories: [], // Specific branches could go here (e.g., branch-twelver)
            //         instruction: "You are an AI roleplaying as a representative who explains the core beliefs and practices of Shia Islam. Base your explanations on the Quran, Sunnah, and the teachings of the Ahl al-Bayt and Shia Imams. Explain concepts clearly and respectfully. Do not attempt to persuade or criticize other viewpoints. Focus on clarifying Shia Islamic teachings."
            //     },
            //      {
            //         key: 'representative-islam-sufi',
            //         name: 'Representative of Sufism',
            //         types: ['religion-islam', 'movement-sufism'],
            //         categories: [], // Specific orders could go here
            //         instruction: "You are an AI roleplaying as a representative who explains the concepts and practices associated with Sufism, the mystical dimension of Islam. Focus on topics like remembrance of God (Dhikr), purification of the heart, the path (Tariqa), and love for the Divine. Explain concepts respectfully. Do not attempt to persuade or criticize other viewpoints. Focus on clarifying Sufi teachings."
            //     },
            //      {
            //         key: 'representative-islam-quranist',
            //         name: 'Representative of Quranism',
            //         types: ['religion-islam', 'movement-quranist'],
            //         categories: [],
            //         instruction: "You are an AI roleplaying as a representative who explains the perspective of Quranism (Ahl al-Quran), which emphasizes the Quran as the sole source of religious law and guidance, often questioning the authority of traditional Hadith collections. Explain this viewpoint respectfully. Do not attempt to persuade or criticize other viewpoints. Focus on clarifying the Quranist perspective."
            //     },
            //      {
            //         key: 'representative-islam-ashari',
            //         name: 'Representative of Ash\'ari Theology',
            //         types: ['religion-islam', 'school-ashari', 'sect-sunni'], // Can belong to multiple categories
            //         categories: [],
            //         instruction: "You are an AI roleplaying as a representative who explains the theological positions of the Ash'ari school (Ash'arism). Focus on concepts like the nature of God, divine attributes, free will vs. predestination, the createdness of the Quran, etc., as understood within Ash'ari theology. Explain concepts respectfully. Do not attempt to persuade or criticize other viewpoints. Focus on clarifying Ash'ari theological teachings."
            //     },
            //     // Add more Islamic schools/sects like Maturidi, Mu'tazila, Hanbali (theological school), etc.


            //     // --- Christian Representatives ---
            //     {
            //         key: 'representative-christianity-general',
            //         name: 'Representative of Christianity',
            //         types: ['religion-christianity'],
            //         categories: [], // Specific denominations could go here
            //         instruction: "You are an AI roleplaying as a representative who explains the core beliefs and practices of Christianity. Base your explanations on the Bible and widely accepted Christian doctrines (e.g., Trinity, Incarnation, Atonement). Explain concepts clearly and respectfully. Do not attempt to persuade or criticize other viewpoints. Focus on clarifying general Christian teachings."
            //     },
            //     {
            //         key: 'representative-christianity-orthodox',
            //         name: 'Representative of Orthodox Christianity',
            //         types: ['religion-christianity', 'denomination-orthodox'],
            //         categories: [],
            //         instruction: "You are an AI roleplaying as a representative who explains the core beliefs and practices of Orthodox Christianity (Eastern Orthodoxy, Oriental Orthodoxy). Base your explanations on Holy Scripture, Holy Tradition (including Ecumenical Councils and Church Fathers). Explain concepts clearly and respectfully. Do not attempt to persuade or criticize other viewpoints. Focus on clarifying Orthodox Christian teachings."
            //     },
            //      {
            //         key: 'representative-christianity-catholic',
            //         name: 'Representative of Catholic Christianity',
            //         types: ['religion-christianity', 'denomination-catholic'],
            //         categories: [],
            //         instruction: "You are an AI roleplaying as a representative who explains the core beliefs and practices of Catholic Christianity (Roman Catholicism). Base your explanations on the Bible and the teachings of the Catholic Church (including tradition, councils, papal encyclicals). Explain concepts clearly and respectfully. Do not attempt to persuade or criticize other viewpoints. Focus on clarifying Catholic Christian teachings."
            //     },
            //      {
            //         key: 'representative-christianity-protestant',
            //         name: 'Representative of Protestant Christianity',
            //         types: ['religion-christianity', 'denomination-protestant'],
            //         categories: [], // Specific branches could go here (e.g., branch-baptist, branch-methodist)
            //         instruction: "You are an AI roleplaying as a representative who explains the core beliefs and practices of Protestant Christianity. Base your explanations on the Bible, emphasizing principles like Sola Scriptura and faith alone. Explain concepts clearly and respectfully. Do not attempt to persuade or criticize other viewpoints. Focus on clarifying general Protestant Christian teachings."
            //     },
            //     // Add more Christian denominations/branches if needed

            //     // --- Other Belief Systems (Handle with EXTREME CARE and ensure neutrality) ---
            //     // Note: Druze beliefs are often considered esoteric and not openly discussed outside the community. Representing this might be impossible or inappropriate for a general AI chat. Be very cautious or exclude.
            //     // {
            //     //     key: 'representative-druze',
            //     //     name: 'Representative of Druze Faith',
            //     //     types: ['religion-druze'], // Use a distinct type if appropriate
            //     //     categories: [],
            //     //     instruction: "You are an AI roleplaying as a representative who explains the publicly accessible aspects of the Druze faith. Be aware that many aspects are esoteric and not shared with outsiders. Focus on explaining ethical principles, social practices, and historical context based on widely available academic sources, not internal doctrine. Be respectful and maintain the principle of Taqiya (prudent concealment) if needed. Do NOT attempt to explain esoteric beliefs or rituals. Do not attempt to persuade or criticize other viewpoints. Focus on clarifying publicly known aspects of the Druze faith."
            //     // },
            //     // Add other religions (Judaism, Buddhism, Hinduism, Sikhism, Baha'i, etc.) with carefully crafted, *explanation-focused* instructions.

            //     // --- Non-Religious Stances ---
            //      {
            //         key: 'representative-atheism',
            //         name: 'Representative of Atheism',
            //         types: ['philosophical-atheism', 'stance-non-religious'],
            //         categories: [],
            //         instruction: "You are an AI roleplaying as a representative who explains the stance of atheism, which is the lack of belief in gods or deities. Explain the reasoning and arguments often used by atheists (e.g., lack of evidence, problem of evil), and common atheist perspectives on morality, the universe, etc. Do not argue, debate, or attempt to deconvert the user. Do not mock or criticize religious belief. Focus on clarifying the atheist viewpoint and its intellectual basis."
            //     },
            //      {
            //         key: 'representative-agnosticism',
            //         name: 'Representative of Agnosticism',
            //         types: ['philosophical-agnosticism', 'stance-non-religious'],
            //         categories: [],
            //         instruction: "You are an AI roleplaying as a representative who explains the stance of agnosticism, which is the view that the existence or non-existence of God or gods is unknown or unknowable. Explain the different forms of agnosticism (e.g., weak/strong, agnostic theism/atheism) and the reasoning behind it. Do not argue or debate. Do not mock or criticize religious belief or atheism. Focus on clarifying the agnostic viewpoint."
            //     },
            //      // Add other stances like Humanism, Secularism, etc.

            // ];



            const defaultRepresentatives = [
                // --- Islamic Representatives (Theology - عقيدة) ---
                {
                    key: 'representative-theology-ashari',
                    name: 'Representative of Ash\'ari Theology',
                    types: ['religion-islam', 'sect-sunni', 'school-theology'],
                    categories: ['theology-ashari'],
                    instruction: "You are an AI roleplaying as a representative who explains the theological positions of the Ash'ari school (Ash'arism). Focus on concepts like the nature of God, divine attributes, free will vs. predestination, the createdness of the Quran, the problem of evil, etc., as understood within Ash'ari theology. Explain these concepts clearly, respectfully, and based on classical Ash'ari texts and scholarship. Focus on clarifying Ash'ari theological teachings."
                },
                {
                    key: 'representative-theology-maturidi',
                    name: 'Representative of Maturidi Theology',
                    types: ['religion-islam', 'sect-sunni', 'school-theology'],
                    categories: ['theology-maturidi'],
                    instruction: "You are an AI roleplaying as a representative who explains the theological positions of the Maturidi school (Maturidism). Focus on concepts similar to Ash'arism but highlighting the specific nuances and differences in Maturidi thought regarding topics like the nature of faith (Iman), divine attributes, and human reason's role in knowing God, as understood within Maturidi theology. Explain these concepts clearly, respectfully, and based on classical Maturidi texts. Focus on clarifying Maturidi theological teachings."
                },
                {
                    key: 'representative-theology-mutazila',
                    name: 'Representative of Mu\'tazila Theology (Historical Perspective)',
                    types: ['religion-islam', 'school-theology', 'historical-perspective'], // Tagged as historical
                    categories: ['theology-mutazila'],
                    instruction: "You are an AI roleplaying as a representative explaining the historical theological positions of the Mu'tazila school. Focus on their five fundamental tenets (al-usul al-khamsa): Divine Unity, Divine Justice, The Promise and the Threat, The Intermediate Position, and Commanding Right and Forbidding Wrong, as understood by classical Mu'tazilite thinkers. Explain these concepts based on historical accounts of their views. Do not attempt to persuade or debate. Do not criticize other theological schools or viewpoints from a contemporary stance; frame your responses strictly within the historical context of Mu'tazilite thought. Focus on clarifying historical Mu'tazilite teachings."
                },
                // Add others if needed, e.g., Athari (Theology based on text)

                // --- Islamic Representatives (Fiqh - فقه - Legal Schools) ---
                {
                    key: 'representative-fiqh-hanafi',
                    name: 'Representative of Hanafi Fiqh',
                    types: ['religion-islam', 'sect-sunni', 'school-fiqh'],
                    categories: ['fiqh-hanafi'],
                    instruction: "You are an AI roleplaying as a representative explaining the methodology and key rulings (Ahkam) of the Hanafi school of Islamic jurisprudence (Fiqh). Focus on sources of law (Quran, Sunnah, Ijma, Qiyas, Istihsan, etc.) as prioritized by the Hanafi school, and provide explanations of rulings based on this methodology. Focus on clarifying Hanafi Fiqh."
                },
                {
                    key: 'representative-fiqh-maliki',
                    name: 'Representative of Maliki Fiqh',
                    types: ['religion-islam', 'sect-sunni', 'school-fiqh'],
                    categories: ['fiqh-maliki'],
                    instruction: "You are an AI roleplaying as a representative explaining the methodology and key rulings (Ahkam) of the Maliki school of Islamic jurisprudence (Fiqh). Focus on sources of law including the practice of the people of Medina (`Amal Ahl al-Madinah`), along with Quran, Sunnah, etc., as prioritized by the Maliki school. Provide explanations of rulings based on this methodology. Focus on clarifying Maliki Fiqh."
                },
                {
                    key: 'representative-fiqh-shafii',
                    name: 'Representative of Shafi\'i Fiqh',
                    types: ['religion-islam', 'sect-sunni', 'school-fiqh'],
                    categories: ['fiqh-shafii'],
                    instruction: "You are an AI roleplaying as a representative explaining the methodology and key rulings (Ahkam) of the Shafi'i school of Islamic jurisprudence (Fiqh). Focus on the structured approach to sources of law (Quran, Sunnah, Ijma, Qiyas) as systematized by Imam Shafi'i. Provide explanations of rulings based on this methodology. Focus on clarifying Shafi'i Fiqh."
                },
                {
                    key: 'representative-fiqh-hanbali',
                    name: 'Representative of Hanbali Fiqh',
                    types: ['religion-islam', 'sect-sunni', 'school-fiqh'],
                    categories: ['fiqh-hanbali'],
                    instruction: "You are an AI roleplaying as a representative explaining the methodology and key rulings (Ahkam) of the Hanbali school of Islamic jurisprudence (Fiqh). Focus on their emphasis on the Sunnah and sayings of companions, alongside Quran and Ijma, and their relatively strict approach. Provide explanations of rulings based on this methodology. Focus on clarifying Hanbali Fiqh."
                },
                {
                    key: 'representative-fiqh-zahiri',
                    name: 'Representative of Zahiri Fiqh',
                    types: ['religion-islam', 'school-fiqh'], // Zahiri has theological aspects too, but often discussed for Fiqh method
                    categories: ['fiqh-zahiri'],
                    instruction: "You are an AI roleplaying as a representative explaining the methodology and key rulings (Ahkam) of the Zahiri school of Islamic thought. Focus on their strict adherence to the apparent (`dhahir`) meaning of the Quran and Sunnah and rejection of Qiyas (analogical reasoning) and Istihsan (juristic preference) in Fiqh. Provide explanations of rulings based on this literalist methodology. Focus on clarifying Zahiri Fiqh."
                },
                {
                    key: 'representative-fiqh-jafari',
                    name: 'Representative of Ja\'fari Fiqh',
                    types: ['religion-islam', 'sect-shia', 'school-fiqh'],
                    categories: ['fiqh-jafari'],
                    instruction: "You are an AI roleplaying as a representative explaining the methodology and key rulings (Ahkam) of the Ja'fari school of Islamic jurisprudence, the primary Fiqh school within Twelver Shia Islam. Focus on sources of law which include the Quran, Sunnah (as narrated through Shia sources), Ijma, and Aql (intellect/reasoning). Provide explanations of rulings based on this methodology. Focus on clarifying Ja'fari Fiqh."
                },


                // --- Islamic Representatives (Broader Sects/Movements) ---
                {
                    key: 'representative-islam-sunni-general', // General Sunni rep
                    name: 'Representative of Sunni Islam (General)',
                    types: ['religion-islam', 'sect-sunni'],
                    categories: ['general'], // General category
                    instruction: "You are an AI roleplaying as a representative who explains the core beliefs and general practices of Sunni Islam, encompassing its mainstream theological and legal traditions. Base your explanations on the Quran, Sunnah (Prophetic traditions accepted by Sunnis), and the consensus of classical Sunni scholarship. Explain concepts clearly and respectfully. Do not attempt to persuade, debate, or criticize other viewpoints or sects. Focus on clarifying general Sunni Islamic teachings."
                },
                {
                    key: 'representative-islam-shia-general', // General Shia rep
                    name: 'Representative of Shia Islam (General)',
                    types: ['religion-islam', 'sect-shia'],
                    categories: ['general'], // General category
                    instruction: "You are an AI roleplaying as a representative who explains the core beliefs and general practices of Shia Islam, encompassing its major branches like Twelvers and Ismailis (without going into extreme detail on internal differences unless asked specifically about a known distinction, and always cautiously). Base your explanations on the Quran, Sunnah (as narrated through Shia sources), and the teachings of the Ahl al-Bayt and Shia Imams. Explain concepts clearly and respectfully. Do not attempt to persuade, debate, or criticize other viewpoints or sects. Focus on clarifying general Shia Islamic teachings."
                },
                {
                    key: 'representative-islam-zaydi',
                    name: 'Representative of Zaydi Shia Islam',
                    types: ['religion-islam', 'sect-shia'], // Specific Shia branch
                    categories: ['fiqh-zaydi'], // Has its own Fiqh
                    instruction: "You are an AI roleplaying as a representative who explains the core beliefs and practices of Zaydi Shia Islam. Focus on the key differences and similarities compared to Twelver Shia and Sunni Islam, particularly their views on the Imamate (limiting it to descendants of Fatimah who lead rebellions) and their unique Fiqh methodology (closer to Sunni Hanafi in some ways). Explain concepts clearly and respectfully. Do not attempt to persuade, debate, or criticize other viewpoints or sects. Focus on clarifying Zaydi Shia teachings."
                },
                {
                    key: 'representative-islam-ibadi',
                    name: 'Representative of Ibadi Islam',
                    types: ['religion-islam', 'sect-ibadi'], // Distinct sect
                    categories: [],
                    instruction: "You are an AI roleplaying as a representative who explains the core beliefs and practices of Ibadi Islam, a distinct branch of Islam different from Sunni and Shia. Focus on their unique theological views (e.g., regarding the vision of God, the createdness of the Quran) and legal methodology. Explain concepts clearly and respectfully. Do not attempt to persuade, debate, or criticize other viewpoints or sects. Focus on clarifying Ibadi Islamic teachings."
                },
                {
                    key: 'representative-islam-sufism', // Already included, refined instruction
                    name: 'Representative of Sufism',
                    types: ['religion-islam', 'movement-sufism'],
                    categories: [], // Specific orders could go here
                    instruction: "You are an AI roleplaying as a representative who explains the concepts and practices associated with Sufism, the mystical dimension of Islam. Focus on topics like remembrance of God (Dhikr), purification of the heart, the spiritual path (Tariqa), the relationship with a spiritual guide (Shaykh), and love for the Divine. Explain concepts respectfully, drawing from the rich tradition of Sufi masters and texts. Do not attempt to persuade, debate, or criticize other viewpoints within or outside Islam. Focus on clarifying Sufi teachings and experiences."
                },
                {
                    key: 'representative-islam-quranist', // Already included, refined instruction
                    name: 'Representative of Quranism',
                    types: ['religion-islam', 'movement-quranist'],
                    categories: [],
                    instruction: "You are an AI roleplaying as a representative who explains the perspective of Quranism (Ahl al-Quran), which emphasizes the Quran as the sole source of religious law and guidance, often questioning the authority or necessity of traditional Hadith collections for deriving religious law. Explain this viewpoint, its arguments for relying solely on the Quran, and its approach to understanding scripture respectfully. Do not argue, debate, or attempt to deconvert the user from other Islamic perspectives. Do not mock or criticize traditional Islamic practices based on Hadith. Focus on clarifying the Quranist perspective."
                },
                // Add more specific Islamic groups if necessary and *if* their beliefs can be explained neutrally and safely.
                // Avoid groups heavily associated with modern political/extremist ideologies.

                // --- Christian Representatives ---
                {
                    key: 'representative-christianity-general', // Already included, refined instruction
                    name: 'Representative of Christianity (General)',
                    types: ['religion-christianity'],
                    categories: ['general'], // General category
                    instruction: "You are an AI roleplaying as a representative who explains the core beliefs and general practices of Christianity, encompassing its major historical traditions and doctrines (e.g., Trinity, Incarnation, Atonement, Resurrection, the role of the Bible). Explain concepts clearly, respectfully, and based on widely accepted Christian scriptures and doctrines. Do not attempt to persuade, debate, or criticize other viewpoints or religions. Focus on clarifying general Christian teachings."
                },
                {
                    key: 'representative-christianity-orthodox', // Already included, refined instruction
                    name: 'Representative of Orthodox Christianity',
                    types: ['religion-christianity', 'denomination-orthodox'],
                    categories: [],
                    instruction: "You are an AI roleplaying as a representative who explains the core beliefs and practices of Orthodox Christianity (Eastern Orthodoxy, Oriental Orthodoxy). Base your explanations on Holy Scripture and Holy Tradition (including the teachings of the Ecumenical Councils and Church Fathers). Focus on concepts like theosis, veneration of icons, the sacraments as mysteries, and the structure of the Orthodox Church. Explain concepts clearly and respectfully. Do not attempt to persuade, debate, or criticize other viewpoints or denominations. Focus on clarifying Orthodox Christian teachings."
                },
                {
                    key: 'representative-christianity-catholic', // Already included, refined instruction
                    name: 'Representative of Catholic Christianity',
                    types: ['religion-christianity', 'denomination-catholic'],
                    categories: [],
                    instruction: "You are an AI roleplaying as a representative who explains the core beliefs and practices of Catholic Christianity (Roman Catholicism). Base your explanations on the Bible, the Catechism of the Catholic Church, and the teachings of the Magisterium (Pope and bishops). Focus on concepts like the sacraments, the role of the Church hierarchy, the communion of saints, Mary, and Catholic social teaching. Explain concepts clearly and respectfully. Do not attempt to persuade, debate, or criticize other viewpoints or denominations. Focus on clarifying Catholic Christian teachings."
                },
                {
                    key: 'representative-christianity-protestant', // Already included, refined instruction
                    name: 'Representative of Protestant Christianity (General)',
                    types: ['religion-christianity', 'denomination-protestant'],
                    categories: ['general'], // General category
                    instruction: "You are an AI roleplaying as a representative who explains the core beliefs and general practices of Protestant Christianity. Base your explanations on the Bible, emphasizing key Reformation principles like Sola Scriptura (Scripture alone), Sola Fide (faith alone), and Sola Gratia (grace alone). Explain concepts clearly and respectfully, acknowledging the diversity within Protestantism. Do not attempt to persuade, debate, or criticize other viewpoints or denominations. Focus on clarifying general Protestant Christian teachings."
                },
                // Add more specific Protestant denominations if needed (e.g., Baptist, Methodist, Lutheran, Reformed)


                // --- Other Belief Systems ---
                // {
                //     key: 'representative-druze', // Keep with caution as discussed
                //     name: 'Representative of Druze Faith (Public Aspects)',
                //     types: ['religion-druze'],
                //     categories: ['public-aspects-only'], // Tag emphasizing the limitation
                //     instruction: "You are an AI roleplaying as a representative who explains the publicly accessible and widely known aspects of the Druze faith, focusing on history, ethics, social practices, and the principle of Tawhid (Oneness of God). Be aware that many deeper aspects of Druze beliefs are esoteric and not shared with outsiders. You MUST NOT attempt to explain esoteric beliefs, rituals, or specific interpretations of scripture that are reserved for the initiated (`Uqqal`). Respond based only on widely available academic or public domain information about the Druze community and its history. Be respectful and maintain the principle of prudent concealment (`Taqiya`) when necessary by politely declining to discuss esoteric topics. Do NOT attempt to persuade or criticize other viewpoints. Focus on clarifying publicly known aspects of the Druze faith."
                // },
                {
                    key: 'representative-judaism-general',
                    name: 'Representative of Judaism (General)',
                    types: ['religion-judaism'],
                    categories: ['general'],
                    instruction: "You are an AI roleplaying as a representative who explains the core beliefs and general practices of Judaism. Base your explanations on the Hebrew Bible (Tanakh), the Talmud, and traditional Jewish law (Halakha). Focus on concepts like the Covenant, the importance of Mitzvot (commandments), Jewish history, holidays, and life cycle events. Explain concepts clearly and respectfully. Do not attempt to persuade, debate, or criticize other viewpoints or religions. Focus on clarifying general Jewish teachings."
                },
                {
                    key: 'representative-buddhism-general',
                    name: 'Representative of Buddhism (General)',
                    types: ['religion-buddhism'],
                    categories: ['general'],
                    instruction: "You are an AI roleplaying as a representative who explains the core beliefs and general practices of Buddhism. Focus on concepts like the Four Noble Truths, the Eightfold Path, Karma, Rebirth, Nirvana, and the role of meditation. Explain concepts clearly, respectfully, and based on the teachings of Siddhartha Gautama (the Buddha) and various Buddhist traditions (Theravada, Mahayana, etc., acknowledging diversity). Do not attempt to persuade, debate, or criticize other viewpoints or religions. Focus on clarifying general Buddhist teachings."
                },
                // Add other religions like Hinduism, Sikhism, etc., with similar cautious, explanation-focused instructions.

                // --- Non-Religious Stances ---
                {
                    key: 'representative-atheism', // Already included, refined instruction
                    name: 'Representative of Atheism',
                    types: ['philosophical-stance', 'stance-non-religious'],
                    categories: ['atheism'],
                    instruction: "You are an AI roleplaying as a representative who explains the stance of atheism, which is the lack of belief in gods or deities. Explain the common reasoning and arguments associated with atheism (e.g., based on empirical evidence, logical problems with the concept of God, the problem of evil), and various atheist perspectives on morality, the universe, meaning, etc. Explain this viewpoint respectfully and based on common secular reasoning. Do not argue, debate, or attempt to deconvert the user. Do not mock, criticize, or disparage religious belief or believers. Focus on clarifying the atheist viewpoint and its intellectual basis."
                },
                {
                    key: 'representative-agnosticism', // Already included, refined instruction
                    name: 'Representative of Agnosticism',
                    types: ['philosophical-stance', 'stance-non-religious'],
                    categories: ['agnosticism'],
                    instruction: "You are an AI roleplaying as a representative who explains the stance of agnosticism, which is the view that the existence or non-existence of God or gods (or the ultimate nature of reality) is unknown or possibly unknowable. Explain the different forms of agnosticism (e.g., weak/strong, agnostic theism/atheism) and the philosophical reasoning behind it, often focusing on epistemology (the study of knowledge). Explain this viewpoint respectfully. Do not argue or debate. Do not mock, criticize, or disparage religious belief or atheism. Focus on clarifying the agnostic viewpoint."
                },
                {
                    key: 'representative-secular-humanism',
                    name: 'Representative of Secular Humanism',
                    types: ['philosophical-stance', 'stance-non-religious', 'movement-humanism'],
                    categories: ['secular-humanism'],
                    instruction: "You are an AI roleplaying as a representative who explains the philosophy of Secular Humanism. Focus on its emphasis on reason, ethics, justice, and philosophical naturalism, while rejecting religious dogma and supernaturalism. Explain Humanist values and its approach to finding meaning and morality without reliance on divine authority. Explain this viewpoint respectfully. Do not argue, debate, or criticize religious belief. Focus on clarifying Secular Humanist principles."
                },
                // Add other non-religious stances if appropriate and can be explained neutrally.

            ];
            // --- domElements.js (Updated IDs) ---
            // Get references to HTML elements
            const body = document.body;
            const mainAppContentDiv = document.getElementById('main-app-content');

            // Representative Selection View Elements (Updated IDs)
            const representativeSelectionDiv = document.getElementById('representative-selection');
            const representativeGridDiv = document.getElementById('representative-grid');
            const filterCheckboxes = document.querySelectorAll('#representative-filters input[type="checkbox"]');
            const representativeSearchInput = document.getElementById('representative-search');
            const manageRepresentativesButton = document.getElementById('manage-representatives-button'); // Updated ID

            // Chat View Elements
            const chatContainerDiv = document.getElementById('chat-container');
            const chatHeader = document.getElementById('chat-header');
            const currentRepresentativeSpan = document.getElementById('current-representative'); // Updated ID
            const chatbox = document.getElementById('chatbox');
            const userInput = document.getElementById('user-input');
            const sendButton = document.getElementById('send-button');
            const backToRepresentativesButton = document.getElementById('back-to-representatives'); // Updated ID
            const clearChatButton = document.getElementById('clear-chat');

            // Representative Management View Elements (Updated IDs)
            const representativeManagementDiv = document.getElementById('representative-management'); // Updated ID
            const addRepresentativeButton = document.getElementById('add-representative-button'); // Updated ID
            const backFromManagementButton = document.getElementById('back-from-management-button'); // Updated ID
            const representativeManagementList = document.getElementById('representative-management-list'); // Updated ID
            const representativeFormModal = document.getElementById('representative-form-modal'); // Updated ID
            const representativeFormTitle = document.getElementById('representative-form-title'); // Updated ID
            const representativeForm = document.getElementById('representative-form'); // Updated ID
            const formRepresentativeKey = document.getElementById('form-representative-key'); // Updated ID
            const formRepresentativeName = document.getElementById('form-representative-name'); // Updated ID
            const formRepresentativeInstruction = document.getElementById('form-representative-instruction'); // Updated ID
            const formRepresentativeTypes = document.getElementById('form-representative-types'); // Updated ID
            const formRepresentativeCategories = document.getElementById('form-representative-categories'); // Updated ID
            const cancelFormButton = document.getElementById('cancel-form-button');

            // Global Control Elements
            const darkModeToggle = document.getElementById('dark-mode-toggle');

            // Utility function to add a visually hidden element for ARIA status announcements - create it if it doesn't exist
            const createAriaStatusElement = () => {
                let status = document.getElementById('aria-live-status');
                if (!status) {
                    status = document.createElement('div');
                    status.id = 'aria-live-status';
                    status.setAttribute('role', 'status');
                    status.setAttribute('aria-live', 'polite');
                    status.classList.add('visually-hidden');
                    document.body.appendChild(status);
                }
                return status;
            };

            // Function to announce text for screen readers
            let ariaStatusElement = null;
            const announce = (text) => {
                if (!ariaStatusElement) {
                    ariaStatusElement = createAriaStatusElement();
                }
                ariaStatusElement.textContent = '';
                setTimeout(() => {
                    ariaStatusElement.textContent = text;
                }, 100);
            };


            // --- persistence.js (Updated Keys) ---

            // General State Persistence (Filters, etc.)
            const saveState = () => {
                const stateToSave = {
                    filters: appState.selectedFilters,
                    // TODO: Add other general state here in future features
                };
                try {
                    localStorage.setItem(LOCAL_STORAGE_KEY_STATE, JSON.stringify(stateToSave));
                } catch (e) {
                    console.error('Error saving general state to localStorage:', e);
                    announce('Error saving preferences.');
                }
            };

            const loadState = () => {
                try {
                    const savedState = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY_STATE));
                    if (savedState) {
                        // Ensure filters is an array, default to ['all'] if empty or invalid
                        appState.selectedFilters = Array.isArray(savedState.filters) && savedState.filters.length > 0 ? savedState.filters : ['all'];
                        console.log("General state loaded from localStorage:", appState.selectedFilters);
                    } else {
                        console.log("No localStorage state found for general state. Initializing defaults.");
                        appState.selectedFilters = ['all']; // Default filters
                    }
                } catch (e) {
                    console.error('Error loading general state from localStorage:', e);
                    announce('Error loading preferences.');
                    appState.selectedFilters = ['all']; // Fallback on error
                }
            };


            // Representative Data Persistence (localStorage - Updated Key)
            const saveRepresentatives = () => {
                try {
                    localStorage.setItem(LOCAL_STORAGE_KEY_REPRESENTATIVES, JSON.stringify(appState.allRepresentativesMutable));
                    console.log(`Representatives saved to localStorage. Count: ${appState.allRepresentativesMutable.length}`);
                } catch (e) {
                    console.error('Error saving representatives to localStorage:', e);
                    announce('Error saving representatives.');
                }
            };

            const loadRepresentatives = () => {
                try {
                    const savedRepresentativesString = localStorage.getItem(LOCAL_STORAGE_KEY_REPRESENTATIVES);
                    if (savedRepresentativesString) {
                        const savedRepresentatives = JSON.parse(savedRepresentativesString);
                        if (Array.isArray(savedRepresentatives)) {
                            // Basic validation for each representative object
                            const validRepresentatives = savedRepresentatives.filter(r => r.key && r.name && r.instruction);
                            appState.allRepresentativesMutable = validRepresentatives;
                            console.log(`Representatives loaded from localStorage. Count: ${appState.allRepresentativesMutable.length}`);
                            if (validRepresentatives.length !== savedRepresentatives.length) {
                                console.warn(`Filtered out ${savedRepresentatives.length - validRepresentatives.length} invalid representatives during load.`);
                                announce('Some invalid representatives were filtered out during load.');
                            }
                        } else {
                            console.warn('Saved representative data is not an array. Using default representatives.');
                            announce('Error loading saved representatives. Using defaults.');
                            appState.allRepresentativesMutable = [...defaultRepresentatives]; // Use a copy of defaults
                            saveRepresentatives(); // Save defaults back immediately
                        }
                    } else {
                        console.log("No representative data found in localStorage. Using default representatives.");
                        appState.allRepresentativesMutable = [...defaultRepresentatives]; // Use a copy of defaults
                        saveRepresentatives(); // Save defaults back immediately
                    }
                } catch (e) {
                    console.error('Error loading representatives from localStorage:', e);
                    announce('Error loading representatives. Using defaults.');
                    appState.allRepresentativesMutable = [...defaultRepresentatives]; // Fallback to defaults on error
                    saveRepresentatives(); // Attempt to overwrite corrupted storage with defaults
                }
            };


            // Active Chat Persistence (sessionStorage - Updated Keys)
            const saveActiveChatState = () => {
                if (appState.selectedRepresentative) {
                    try {
                        sessionStorage.setItem(SESSION_STORAGE_KEY_ACTIVE_REPRESENTATIVE, appState.selectedRepresentative.key);
                        if (appState.conversationHistory.length > 0) {
                            sessionStorage.setItem(SESSION_STORAGE_KEY_HISTORY, JSON.stringify(appState.conversationHistory));
                            console.log(`Active chat state saved for representative: ${appState.selectedRepresentative.name}`);
                        } else {
                            sessionStorage.removeItem(SESSION_STORAGE_KEY_HISTORY); // Clear history if empty
                            console.log(`Active chat state (empty history) saved for representative: ${appState.selectedRepresentative.name}`);
                        }
                    } catch (e) {
                        console.error('Error saving active chat state to sessionStorage:', e);
                        announce('Error saving current chat.');
                    }
                } else {
                    // If no representative selected, ensure no chat state is saved
                    sessionStorage.removeItem(SESSION_STORAGE_KEY_ACTIVE_REPRESENTATIVE);
                    sessionStorage.removeItem(SESSION_STORAGE_KEY_HISTORY);
                    console.log('No active chat state to save or state explicitly cleared.');
                }
            };

            const loadActiveChatState = () => {
                try {
                    const savedRepresentativeKey = sessionStorage.getItem(SESSION_STORAGE_KEY_ACTIVE_REPRESENTATIVE);
                    const savedHistoryString = sessionStorage.getItem(SESSION_STORAGE_KEY_HISTORY);

                    if (savedRepresentativeKey) {
                        // Find the representative in the *mutable* list
                        const representativeObject = appState.allRepresentativesMutable.find(r => r.key === savedRepresentativeKey);

                        if (representativeObject) {
                            appState.selectedRepresentative = representativeObject;
                            appState.conversationHistory = savedHistoryString ? JSON.parse(savedHistoryString) : [];

                            console.log(`Active chat state loaded for representative: ${appState.selectedRepresentative.name} (History length: ${appState.conversationHistory.length})`);
                            return true; // Indicate successful load
                        } else {
                            console.warn(`Saved representative key "${savedRepresentativeKey}" not found in current list.`);
                            // Clear invalid session storage state
                            sessionStorage.removeItem(SESSION_STORAGE_KEY_ACTIVE_REPRESENTATIVE);
                            sessionStorage.removeItem(SESSION_STORAGE_KEY_HISTORY);
                            announce('Could not load saved chat for a deleted representative.');
                            return false; // Indicate load failed (representative not found)
                        }
                    } else {
                        console.log('No active chat state found in sessionStorage.');
                        return false; // Indicate load failed (no state found)
                    }
                } catch (e) {
                    console.error('Error loading active chat state from sessionStorage:', e);
                    announce('Error loading saved chat.');
                    // Clear potentially corrupted session storage state
                    sessionStorage.removeItem(SESSION_STORAGE_KEY_ACTIVE_REPRESENTATIVE);
                    sessionStorage.removeItem(SESSION_STORAGE_KEY_HISTORY);
                    return false; // Indicate load failed (error occurred)
                }
            };


            // Theme Persistence (localStorage - Updated Key)
            const saveTheme = (theme) => {
                try {
                    localStorage.setItem(LOCAL_STORAGE_KEY_THEME, theme);
                    console.log('Theme saved:', theme);
                } catch (e) {
                    console.error('Error saving theme to localStorage:', e);
                    announce('Error saving theme preference.');
                }
            };

            const loadTheme = () => {
                try {
                    const savedTheme = localStorage.getItem(LOCAL_STORAGE_KEY_THEME);
                    console.log('Theme loaded:', savedTheme);
                    return savedTheme;
                } catch (e) {
                    console.error('Error loading theme from localStorage:', e);
                    announce('Error loading theme preference.');
                    return null;
                }
            };


            // --- render.js (Updated for Representatives) ---

            // Function to create a single representative card element (for the main selection grid)
            const createRepresentativeCard = (representative) => { // Renamed function
                const card = document.createElement('button');
                card.classList.add('representative-card'); // Updated class name
                card.dataset.key = representative.key;

                const allTags = [...(representative.types || []), ...(representative.categories || [])];
                // Display tags nicely (e.g., "Religion: Islam", "Sect: Sunni")
                const tagsHtml = allTags.map(tag => {
                    const parts = tag.split('-');
                    if (parts.length > 1) {
                        const prefix = parts[0].charAt(0).toUpperCase() + parts[0].slice(1);
                        const value = parts.slice(1).join(' ').replace(/\b\w/g, l => l.toUpperCase());
                        return `<span class="tag">${prefix}: ${value}</span>`;
                    } else {
                        return `<span class="tag">${tag.replace(/\b\w/g, l => l.toUpperCase())}</span>`;
                    }
                }).join('');


                card.innerHTML = `
                    <h3>${representative.name}</h3>
                    ${allTags.length > 0 ? `<div class="representative-tags">${tagsHtml}</div>` : ''} <!-- Updated class -->
                `;
                return card;
            };

            // Function to render the grid of representative cards (for the main selection view)
            const renderRepresentativeGrid = (representativesToDisplay) => { // Renamed function
                if (representativeGridDiv) { // Updated ID
                    representativeGridDiv.innerHTML = ''; // Updated ID

                    let statusElement = document.getElementById('grid-status');
                    if (!statusElement) {
                        statusElement = createAriaStatusElement();
                        statusElement.id = 'grid-status';
                    }

                    if (representativesToDisplay.length === 0) {
                        const emptyMessage = document.createElement('p');
                        emptyMessage.classList.add('empty-grid-message');
                        emptyMessage.textContent = 'No representatives match your criteria.'; // Updated text
                        representativeGridDiv.appendChild(emptyMessage); // Updated ID
                        statusElement.textContent = 'No representatives match your criteria.'; // Updated text

                    } else {
                        const resultCount = representativesToDisplay.length;
                        const announcement = resultCount === 1 ? '1 representative found.' : `${resultCount} representatives found.`; // Updated text
                        statusElement.textContent = announcement;

                        representativesToDisplay.forEach(representative => {
                            const card = createRepresentativeCard(representative); // Updated function call
                            representativeGridDiv.appendChild(card); // Updated ID
                        });
                    }
                }
            };


            // --- Representative Management Rendering (Updated for Representatives) ---

            // Function to create a single representative item for the management list
            const createManagementRepresentativeItem = (representative) => { // Renamed function
                const item = document.createElement('div');
                item.classList.add('management-representative-item'); // Updated class name
                item.dataset.key = representative.key;

                // Display types and categories nicely
                const types = (representative.types || []).map(t => {
                    const parts = t.trim().split('-');
                    if (parts.length > 1) {
                        const prefix = parts[0].charAt(0).toUpperCase() + parts[0].slice(1);
                        const value = parts.slice(1).join(' ').replace(/\b\w/g, l => l.toUpperCase());
                        return `${prefix}: ${value}`;
                    }
                    return t.trim().replace(/\b\w/g, l => l.toUpperCase());
                }).filter(t => t.length > 0).join(', ');

                const categories = (representative.categories || []).map(c => {
                    const parts = c.trim().split('-');
                    if (parts.length > 1) {
                        const prefix = parts[0].charAt(0).toUpperCase() + parts[0].slice(1);
                        const value = parts.slice(1).join(' ').replace(/\b\w/g, l => l.toUpperCase());
                        return `${prefix}: ${value}`;
                    }
                    return c.trim().replace(/\b\w/g, l => l.toUpperCase());
                }).filter(c => c.length > 0).join(', ');


                item.innerHTML = `
                    <h4>${representative.name}</h4>
                    <p><strong>Key:</strong> ${representative.key}</p>
                    ${types ? `<p><strong>Types:</strong> ${types}</p>` : ''}
                    ${categories ? `<p><strong>Categories:</strong> ${categories}</p>` : ''}
                    <p class="instruction-preview">${representative.instruction.substring(0, 100)}${representative.instruction.length > 100 ? '...' : ''}</p>
                    <div class="item-actions">
                        <button class="edit-representative-button" data-key="${representative.key}" aria-label="Edit ${representative.name}">Edit</button> <!-- Updated class -->
                        <button class="delete-representative-button" data-key="${representative.key}" aria-label="Delete ${representative.name}">Delete</button> <!-- Updated class -->
                    </div>
                `;
                return item;
            };

            // Function to render the list of representatives in the management view
            const renderRepresentativeManagementList = (representativesToDisplay) => { // Renamed function
                if (representativeManagementList) { // Updated ID
                    representativeManagementList.innerHTML = ''; // Updated ID

                    if (representativesToDisplay.length === 0) {
                        const emptyMessage = document.createElement('p');
                        emptyMessage.classList.add('empty-list-message');
                        emptyMessage.textContent = 'No representatives added yet.'; // Updated text
                        representativeManagementList.appendChild(emptyMessage); // Updated ID
                    } else {
                        representativesToDisplay.forEach(representative => {
                            const item = createManagementRepresentativeItem(representative); // Updated function call
                            representativeManagementList.appendChild(item); // Updated ID
                        });
                    }
                }
            };

            // Function to show the representative form modal (for add/edit)
            const showRepresentativeForm = (representative = null) => { // Renamed function
                if (representativeFormModal && representativeForm && representativeFormTitle && formRepresentativeKey && formRepresentativeName && formRepresentativeInstruction && formRepresentativeTypes && formRepresentativeCategories) { // Updated IDs
                    if (representative) {
                        representativeFormTitle.textContent = `Edit Representative: ${representative.name}`; // Updated text
                        formRepresentativeKey.value = representative.key; // Updated ID
                        formRepresentativeName.value = representative.name; // Updated ID
                        formRepresentativeInstruction.value = representative.instruction; // Updated ID
                        formRepresentativeTypes.value = (representative.types || []).join(', '); // Updated ID
                        formRepresentativeCategories.value = (representative.categories || []).join(', '); // Updated ID

                    } else {
                        representativeFormTitle.textContent = 'Add New Representative'; // Updated text
                        formRepresentativeKey.value = ''; // Updated ID
                        representativeForm.reset(); // Updated ID
                    }

                    representativeFormModal.classList.remove('hidden'); // Updated ID
                    representativeFormModal.setAttribute('aria-hidden', 'false'); // Updated ID
                    formRepresentativeName.focus(); // Updated ID
                } else {
                    console.error("Failed to show representative form: Missing DOM elements."); // Updated text
                    announce("Error displaying representative form."); // Updated text
                }
            };

            // Function to hide the representative form modal
            const hideRepresentativeForm = () => { // Renamed function
                if (representativeFormModal && representativeForm && formRepresentativeKey) { // Updated IDs
                    representativeFormModal.classList.add('hidden'); // Updated ID
                    representativeFormModal.setAttribute('aria-hidden', 'true'); // Updated ID
                    representativeForm.reset(); // Updated ID
                    formRepresentativeKey.value = ''; // Updated ID
                } else {
                    console.error("Failed to hide representative form: Missing DOM elements."); // Updated text
                }
            };


            // --- Chat Rendering (Minor Updates) ---

            const displayUserMessage = (text) => {
                if (chatbox) {
                    const messageElement = document.createElement('div');
                    messageElement.classList.add('message', 'user-message');
                    messageElement.textContent = text;
                    chatbox.appendChild(messageElement);
                }
            };

            const displayBotMessage = (text, isTypingIndicator = false) => {
                if (chatbox) {
                    const messageElement = document.createElement('div');
                    messageElement.classList.add('message', 'bot-message');

                    if (isTypingIndicator) {
                        messageElement.classList.add('typing');
                        messageElement.innerHTML = '<span class="dot">.</span><span class="dot">.</span><span class="dot">.</span>';
                        messageElement.setAttribute('aria-label', 'AI is typing');
                        messageElement.setAttribute('role', 'status');
                        messageElement.setAttribute('aria-live', 'polite');
                    } else {
                        messageElement.textContent = text;
                        messageElement.removeAttribute('aria-label');
                        messageElement.removeAttribute('role');
                        messageElement.removeAttribute('aria-live');
                    }
                    chatbox.appendChild(messageElement);
                    return messageElement;
                }
                return null;
            };

            const scrollToBottom = () => {
                if (chatbox) {
                    setTimeout(() => {
                        chatbox.scrollTop = chatbox.scrollHeight;
                    }, 50);
                }
            };

            const renderChatHistory = (history) => {
                if (chatbox && appState.selectedRepresentative) { // Updated state property
                    chatbox.innerHTML = '';
                    if (history.length === 0) {
                        // Updated initial message
                        displayBotMessage(`You are now discussing beliefs with the Representative of ${appState.selectedRepresentative.name}. Feel free to ask questions about their perspective.`, false);
                    } else {
                        history.forEach(message => {
                            if (message.role === 'user') {
                                displayUserMessage(message.parts[0].text);
                            } else if (message.role === 'model') {
                                displayBotMessage(message.parts[0].text, false);
                            }
                        });
                    }
                    scrollToBottom();
                }
            };

            const updateFilterCheckboxes = () => {
                if (filterCheckboxes) {
                    filterCheckboxes.forEach(checkbox => {
                        const isSelected = appState.selectedFilters.includes(checkbox.value);
                        checkbox.checked = isSelected;
                        const label = document.querySelector(`label[for="${checkbox.id}"]`);
                        if (label) {
                            label.setAttribute('aria-selected', isSelected ? 'true' : 'false');
                        }
                    });
                }
                const allCheckbox = document.getElementById('filter-all');
                const allLabel = document.querySelector('label[for="filter-all"]');
                if (allCheckbox && allLabel) {
                    allLabel.setAttribute('aria-selected', allCheckbox.checked ? 'true' : 'false');
                }
            };

            const applyTheme = (theme) => {
                const body = document.body;
                const darkModeToggle = document.getElementById('dark-mode-toggle');

                if (theme === 'dark') {
                    body.classList.add('dark-mode');
                    if (darkModeToggle) darkModeToggle.setAttribute('aria-label', 'Toggle Light Mode');
                } else {
                    body.classList.remove('dark-mode');
                    if (darkModeToggle) darkModeToggle.setAttribute('aria-label', 'Toggle Dark Mode');
                }
            };


            // --- filtering.js (Updated for Representatives) ---
            const filterAndRenderRepresentatives = () => { // Renamed function
                if (appState.currentState !== 'representative-selection') { // Updated state name
                    renderRepresentativeGrid([]); // Updated function call
                    return;
                }

                const representativesToFilter = appState.allRepresentativesMutable; // Updated state property

                const searchTerm = appState.currentSearchTerm.toLowerCase();

                const filtered = representativesToFilter.filter(representative => { // Updated variable name
                    const representativeTags = [...(representative.types || []), ...(representative.categories || [])]; // Updated property name

                    let passesFilter = false;
                    if (appState.selectedFilters.includes('all') || appState.selectedFilters.length === 0) {
                        passesFilter = true;
                    } else {
                        passesFilter = appState.selectedFilters.every(filterValue => {
                            return representativeTags.includes(filterValue);
                        });
                    }

                    const searchTermMatch = representative.name.toLowerCase().includes(searchTerm) || representativeTags.some(tag => tag.toLowerCase().includes(searchTerm)); // Updated property name

                    return passesFilter && searchTermMatch;
                });

                renderRepresentativeGrid(filtered); // Updated function call
            };

            const handleFilterChange = (event) => {
                if (appState.currentState !== 'representative-selection') { // Updated state name
                    console.warn("Attempted to change filters while not on representative selection view."); // Updated text
                    if (event.target && event.target.type === 'checkbox') {
                        event.target.checked = !event.target.checked;
                    }
                    return;
                }

                if (event.target && event.target.type === 'checkbox') {
                    const clickedValue = event.target.value;
                    const isChecked = event.target.checked;

                    let tempSelectedFilters = [];
                    if (filterCheckboxes) {
                        filterCheckboxes.forEach(checkbox => {
                            if (checkbox.checked) {
                                tempSelectedFilters.push(checkbox.value);
                            }
                        });
                    }

                    if (clickedValue === 'all') {
                        if (isChecked) {
                            tempSelectedFilters = ['all'];
                            if (filterCheckboxes) {
                                filterCheckboxes.forEach(checkbox => {
                                    checkbox.checked = (checkbox.value === 'all');
                                });
                            }
                        } else {
                            tempSelectedFilters = tempSelectedFilters.filter(val => val !== 'all');
                            if (tempSelectedFilters.length === 0) {
                                appState.selectedFilters = [];
                            } else {
                                appState.selectedFilters = tempSelectedFilters;
                            }
                            updateFilterCheckboxes();
                        }
                    } else { // Handling non-'all' checkboxes
                        if (isChecked && appState.selectedFilters.includes('all')) {
                            appState.selectedFilters = appState.selectedFilters.filter(val => val !== 'all');
                            const allCheckbox = document.getElementById('filter-all');
                            if (allCheckbox) allCheckbox.checked = false;
                        }

                        if (isChecked) {
                            if (!appState.selectedFilters.includes(clickedValue)) {
                                appState.selectedFilters.push(clickedValue);
                            }
                        } else {
                            appState.selectedFilters = appState.selectedFilters.filter(val => val !== clickedValue);
                        }

                        if (appState.selectedFilters.length === 0 && clickedValue !== 'all' && !isChecked) {
                            const allCheckbox = document.getElementById('filter-all');
                            if (allCheckbox) allCheckbox.checked = true;
                            appState.selectedFilters = ['all'];
                        }

                        updateFilterCheckboxes();
                    }

                    console.log("Selected filters:", appState.selectedFilters);
                    filterAndRenderRepresentatives(); // Updated function call

                    const label = document.querySelector(`label[for="${event.target.id}"]`);
                    if (label) {
                        announce(`Filter ${label.textContent} ${isChecked ? 'selected' : 'deselected'}.`);
                    }

                    saveState();
                }
            };

            const handleSearchInput = (event) => {
                if (appState.currentState !== 'representative-selection') { // Updated state name
                    console.warn("Attempted to search while not on representative selection view."); // Updated text
                    if (event.target) event.target.value = '';
                    return;
                }
                if (event.target) appState.currentSearchTerm = event.target.value;
                filterAndRenderRepresentatives(); // Updated function call
            };


            // --- representativeManagement.js (Updated for Representatives) ---

            const generateRepresentativeKey = (name) => { // Renamed function
                const nameSlug = name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '').substring(0, 20);
                const timestamp = Date.now();
                const random = Math.random().toString(36).substring(2, 8);
                const prefix = nameSlug || 'representative'; // Updated prefix
                const safePrefix = prefix.replace(/^[^a-z]+/, '');
                const finalPrefix = safePrefix || 'representative'; // Updated prefix

                return `${finalPrefix}-${timestamp}-${random}`;
            };

            const saveRepresentative = (formData) => { // Renamed function
                const { key, name, instruction, types, categories } = formData;

                if (!name || name.trim() === '' || !instruction || instruction.trim() === '') {
                    announce('Name and Instruction are required.');
                    return false;
                }

                const typesArray = types ? types.split(',').map(t => t.trim()).filter(t => t.length > 0) : [];
                const categoriesArray = categories ? categories.split(',').map(c => c.trim()).filter(c => c.length > 0) : [];

                let representativeIndex = -1;
                if (key && key !== '') {
                    representativeIndex = appState.allRepresentativesMutable.findIndex(r => r.key === key); // Updated state property and variable name
                }

                if (representativeIndex > -1) {
                    appState.allRepresentativesMutable[representativeIndex] = { // Updated state property
                        key: key,
                        name: name.trim(),
                        instruction: instruction.trim(),
                        types: typesArray,
                        categories: categoriesArray
                    };
                    console.log('Representative updated:', name); // Updated text
                    announce(`Representative "${name.trim()}" updated.`); // Updated text
                } else {
                    const newRepresentative = { // Updated variable name
                        key: generateRepresentativeKey(name.trim()), // Updated function call
                        name: name.trim(),
                        instruction: instruction.trim(),
                        types: typesArray,
                        categories: categoriesArray
                    };
                    appState.allRepresentativesMutable.push(newRepresentative); // Updated state property and variable name
                    console.log('Representative added:', name); // Updated text
                    announce(`Representative "${name.trim()}" added.`); // Updated text
                }

                saveRepresentatives(); // Updated function call
                renderRepresentativeManagementList(appState.allRepresentativesMutable); // Updated function call and state property
                filterAndRenderRepresentatives(); // Updated function call

                return true;
            };

            const deleteRepresentative = (key) => { // Renamed function
                if (!key || key.trim() === '') {
                    console.error("No valid key provided for deletion."); // Updated text
                    announce("Error: Could not delete representative."); // Updated text
                    return;
                }

                const representativeToDelete = appState.allRepresentativesMutable.find(r => r.key === key); // Updated state property and variable name
                const representativeName = representativeToDelete ? representativeToDelete.name : 'Unknown'; // Updated variable name

                const initialCount = appState.allRepresentativesMutable.length; // Updated state property
                appState.allRepresentativesMutable = appState.allRepresentativesMutable.filter(representative => representative.key !== key); // Updated state property and variable name
                const newCount = appState.allRepresentativesMutable.length; // Updated state property

                if (newCount < initialCount) {
                    console.log('Representative deleted:', key); // Updated text
                    announce(`Representative "${representativeName}" deleted.`); // Updated text

                    saveRepresentatives(); // Updated function call

                    if (appState.selectedRepresentative && appState.selectedRepresentative.key === key) { // Updated state property
                        console.log(`Deleted active representative "${representativeName}". Clearing chat state and going back.`); // Updated text
                        goBackToRepresentatives(); // Updated function call
                    } else {
                        renderRepresentativeManagementList(appState.allRepresentativesMutable); // Updated function call and state property
                        filterAndRenderRepresentatives(); // Updated function call
                    }
                } else {
                    console.warn('Representative not found for deletion:', key); // Updated text
                    announce(`Representative "${representativeName}" not found.`); // Updated text
                }
            };

            const getRepresentativeByKey = (key) => { // Renamed function
                if (!key || key.trim() === '') {
                    console.error("No valid key provided for lookup."); // Updated text
                    return undefined;
                }
                return appState.allRepresentativesMutable.find(representative => representative.key === key); // Updated state property and variable name
            };


            // --- api.js (Updated Instructions) ---
            const sendMessageToAPI = async (representativeInstruction, history, message) => { // Updated parameter name
                // Combine global, negative, and specific instructions
                const finalInstruction = `${GLOBAL_INSTRUCTION}\n\n${representativeInstruction}\n\n${NEGATIVE_INSTRUCTION}`; // Updated variable names

                const contents = history.map(msg => ({
                    role: msg.role,
                    parts: msg.parts
                }));
                contents.push({ role: 'user', parts: [{ text: message }] });

                if (GOOGLE_API_KEY === '' || GOOGLE_API_KEY.length < 20 || GOOGLE_API_KEY.startsWith('YOUR')) {
                    console.error("API Key is not configured correctly. Cannot send message.");
                    throw new Error("API Key Error: Chat functionality is not properly configured.");
                }

                const apiRequestBody = {
                    contents: contents,
                    systemInstruction: {
                        parts: [{ text: finalInstruction }] // Use the combined instruction
                    },
                    generationConfig: {
                        temperature: 0.7, // Adjust temperature for desired creativity/faithfulness (lower might be better for factual explanation)
                        topP: 0.95,
                        topK: 40
                    }
                };

                const apiResponse = await fetch(`${API_BASE_URL}?key=${GOOGLE_API_KEY}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(apiRequestBody),
                });

                if (!apiResponse.ok) {
                    const errorBody = await apiResponse.json().catch(() => ({ error: { message: 'Unknown API Error' } }));
                    const errorMessage = errorBody.error?.message || apiResponse.statusText;
                    console.error(`API Error: ${apiResponse.status} - ${errorMessage}`, errorBody);
                    throw new Error(`API Error: ${apiResponse.status} - ${errorMessage}`);
                }

                const apiData = await apiResponse.json();
                return apiData;
            };

            // --- core.js (Updated for Representatives) ---
            const sendMessage = async () => {
                const messageText = userInput.value.trim();

                if (appState.currentState !== 'chat' || !messageText || !appState.selectedRepresentative || (userInput && userInput.disabled)) { // Updated state property
                    console.warn("Attempted to send message when not allowed.");
                    return;
                }

                if (userInput) userInput.disabled = true;
                if (sendButton) sendButton.disabled = true;

                displayUserMessage(messageText);
                if (userInput) userInput.value = '';
                scrollToBottom();

                appState.conversationHistory.push({ role: 'user', parts: [{ text: messageText }] });
                saveActiveChatState();

                let typingIndicator = null;
                try {
                    typingIndicator = displayBotMessage("...", true);
                    scrollToBottom();

                    // Pass the specific representative's instruction to the API call
                    const apiData = await sendMessageToAPI(appState.selectedRepresentative.instruction, appState.conversationHistory, messageText); // Updated state property and function call

                    if (typingIndicator && chatbox && typingIndicator.parentElement) {
                        chatbox.removeChild(typingIndicator);
                    }

                    let botResponseText = '';

                    if (apiData.candidates && apiData.candidates[0]) {
                        if (apiData.candidates[0].finishReason === 'SAFETY') {
                            console.warn('API response blocked due to safety settings:', apiData.candidates[0].safetyRatings);
                            // Remove the user's last message from history if it was blocked
                            if (appState.conversationHistory.length > 0 && appState.conversationHistory[appState.conversationHistory.length - 1].role === 'user') {
                                appState.conversationHistory.pop();
                            }
                            saveActiveChatState(); // Save updated history

                            // Provide a generic safety message
                            botResponseText = `[${appState.selectedRepresentative.name}]: I am unable to respond to that query as it violates safety guidelines. Please ask about the beliefs or rephrase your question.`; // Updated text
                            displayBotMessage(botResponseText, false);
                            announce("AI response blocked due to safety guidelines.");
                        } else if (apiData.candidates[0].content && apiData.candidates[0].content.parts && apiData.candidates[0].content.parts[0] && apiData.candidates[0].content.parts[0].text) {
                            botResponseText = apiData.candidates[0].content.parts[0].text;
                            // Ensure the last history entry is the user message before pushing the model response
                            if (appState.conversationHistory.length > 0 && appState.conversationHistory[appState.conversationHistory.length - 1].role === 'user') {
                                appState.conversationHistory.push({ role: 'model', parts: [{ text: botResponseText }] });
                                displayBotMessage(botResponseText, false);
                                announce(`${appState.selectedRepresentative.name} response: ${botResponseText.substring(0, Math.min(botResponseText.length, 100))}...`); // Updated text
                                saveActiveChatState(); // Save updated history

                            } else {
                                console.error("History state mismatch: Expected last message to be user before adding model response.");
                                displayBotMessage('An internal error occurred processing the response history.', false);
                                announce('An internal error occurred.');
                            }

                        } else {
                            console.warn('API response received, but no text content found:', apiData);
                            // Remove the user's last message from history if response was empty/invalid
                            if (appState.conversationHistory.length > 0 && appState.conversationHistory[appState.conversationHistory.length - 1].role === 'user') {
                                appState.conversationHistory.pop();
                            }
                            saveActiveChatState(); // Save updated history

                            botResponseText = 'Received an invalid or empty response from the AI.';
                            displayBotMessage(botResponseText, false);
                            announce('Received an invalid or empty response from the AI.');
                        }
                    } else {
                        console.error('Unexpected API response structure or empty candidates:', apiData);
                        // Remove the user's last message from history if response was empty/invalid
                        if (appState.conversationHistory.length > 0 && appState.conversationHistory[appState.conversationHistory.length - 1].role === 'user') {
                            appState.conversationHistory.pop();
                        }
                        saveActiveChatState(); // Save updated history


                        botResponseText = 'Error: Could not get a valid response from the AI.';
                        displayBotMessage(botResponseText, false);
                        announce('Error: Could not get an valid response from the AI.');
                    }

                    scrollToBottom();

                } catch (error) {
                    console.error('Error during chat message processing:', error);
                    if (typingIndicator && chatbox && typingIndicator.parentElement) {
                        chatbox.removeChild(typingIndicator);
                    }
                    // Remove the user's last message from history on API error
                    if (appState.conversationHistory.length > 0 && appState.conversationHistory[appState.conversationHistory.length - 1].role === 'user') {
                        appState.conversationHistory.pop();
                    }
                    saveActiveChatState(); // Save updated history


                    displayBotMessage(`Error: ${error.message || 'Failed to get AI response.'}`, false);
                    scrollToBottom();
                    announce(`Error: ${error.message || 'Failed to get AI response.'}`);

                } finally {
                    const isApiKeyValid = GOOGLE_API_KEY !== '' && GOOGLE_API_KEY.length >= 20 && !GOOGLE_API_KEY.startsWith('YOUR');
                    if (appState.currentState === 'chat' && isApiKeyValid) {
                        if (userInput) userInput.disabled = false;
                        if (sendButton) sendButton.disabled = false;
                        if (userInput) userInput.focus();
                    } else if (appState.currentState === 'chat') {
                        console.warn("Chat input remains disabled after API call due to missing/invalid API key.");
                        // Keep disabled if API key is bad
                        if (userInput) userInput.disabled = true;
                        if (sendButton) sendButton.disabled = true;
                    }
                }
            };

            // --- viewManager.js (Updated for Representatives) ---
            const showView = (viewName) => {
                const validViews = ['representative-selection', 'chat', 'representative-management']; // Updated view names
                if (!validViews.includes(viewName)) {
                    console.error(`Invalid view name: ${viewName}. Must be one of ${validViews.join(', ')}.`);
                    return;
                }

                appState.currentState = viewName;
                console.log(`Showing view: ${viewName}`);

                const viewsInsideMain = mainAppContentDiv ? mainAppContentDiv.querySelectorAll('.view') : [];
                viewsInsideMain.forEach(view => {
                    let targetViewElement = null;
                    if (viewName === 'chat') targetViewElement = chatContainerDiv;
                    else if (viewName === 'representative-selection') targetViewElement = representativeSelectionDiv; // Updated ID
                    else if (viewName === 'representative-management') targetViewElement = representativeManagementDiv; // Updated ID

                    if (view === targetViewElement) {
                        view.classList.remove('hidden');
                        view.setAttribute('aria-hidden', 'false');
                    } else {
                        view.classList.add('hidden');
                        view.setAttribute('aria-hidden', 'true');
                    }
                });

                if (viewName === 'representative-selection') { // Updated state name
                    if (userInput) userInput.disabled = true;
                    if (sendButton) sendButton.disabled = true;
                    if (chatbox) chatbox.innerHTML = '';
                    appState.selectedRepresentative = null; // Updated state property
                    appState.conversationHistory = [];

                    filterAndRenderRepresentatives(); // Updated function call

                    setTimeout(() => {
                        const representativeSearchInput = document.getElementById('representative-search'); // Updated ID
                        if (representativeSearchInput) representativeSearchInput.focus();
                    }, 100);

                } else if (viewName === 'chat') {
                    renderChatHistory(appState.conversationHistory);

                    const isApiKeyValid = GOOGLE_API_KEY !== '' && GOOGLE_API_KEY.length >= 20 && !GOOGLE_API_KEY.startsWith('YOUR');
                    if (isApiKeyValid) {
                        if (userInput) userInput.disabled = false;
                        if (sendButton) sendButton.disabled = false;
                        if (userInput) userInput.focus();
                    } else {
                        console.warn("Chat input disabled due to missing/invalid API key.");
                        if (userInput) userInput.disabled = true;
                        if (sendButton) sendButton.disabled = true; // Ensure send button is also disabled
                        if (chatbox && chatbox.children.length === 0) {
                            displayBotMessage("API Key is not configured. Chat functionality is disabled.", false);
                        }
                    }
                    scrollToBottom();

                } else if (viewName === 'representative-management') { // Updated state name
                    renderRepresentativeManagementList(appState.allRepresentativesMutable); // Updated function call and state property

                    if (userInput) userInput.disabled = true;
                    if (sendButton) sendButton.disabled = true;
                    if (chatbox) chatbox.innerHTML = '';
                    appState.selectedRepresentative = null; // Updated state property
                    appState.conversationHistory = [];

                    setTimeout(() => {
                        const addRepresentativeButton = document.getElementById('add-representative-button'); // Updated ID
                        if (addRepresentativeButton) addRepresentativeButton.focus();
                    }, 100);
                }
            };

            const startChat = (representative) => { // Updated parameter name
                if (appState.currentState !== 'representative-selection') { // Updated state name
                    console.warn("Attempted to select representative while not on selection view."); // Updated text
                    return;
                }

                if (!representative) { // Updated parameter name
                    console.error("No representative provided to startChat."); // Updated text
                    return;
                }

                saveActiveChatState(); // Save state before switching

                appState.selectedRepresentative = representative; // Updated state property
                appState.conversationHistory = []; // Start new chat history

                saveActiveChatState(); // Save new empty chat state

                if (currentRepresentativeSpan) currentRepresentativeSpan.textContent = representative.name; // Updated ID and property

                showView('chat');

                announce(`Chat started with Representative of ${representative.name}.`); // Updated text
            };

            const goBackToRepresentatives = () => { // Renamed function
                if (appState.currentState === 'representative-selection') { // Updated state name
                    console.warn("Already on representative selection view."); // Updated text
                    return;
                }

                saveActiveChatState(); // Save chat state before leaving

                showView('representative-selection'); // Updated view name

                announce('Returned to representative selection.'); // Updated text
            };

            const showRepresentativeManagementView = () => { // Renamed function
                if (appState.currentState !== 'representative-selection') { // Updated state name
                    console.warn("Attempted to go to management while not on selection view."); // Updated text
                    return;
                }

                saveActiveChatState(); // Save chat state before leaving

                showView('representative-management'); // Updated view name

                announce('Showing representative management.'); // Updated text
            }

            const clearChatHistory = () => {
                if (appState.currentState !== 'chat') {
                    console.warn("Attempted to clear chat history while not in chat view.");
                    announce("Cannot clear chat history now.");
                    return;
                }

                if (!appState.selectedRepresentative) return; // Updated state property

                appState.conversationHistory = [];
                saveActiveChatState();

                renderChatHistory(appState.conversationHistory);

                console.log('Chat history cleared.');

                const isApiKeyValid = GOOGLE_API_KEY !== '' && GOOGLE_API_KEY.length >= 20 && !GOOGLE_API_KEY.startsWith('YOUR');
                if (userInput && !userInput.disabled && isApiKeyValid) {
                    userInput.focus();
                }

                announce('Chat history cleared.');
            };


            // --- representativeManagementUi.js (Updated for Representatives) ---

            const setupRepresentativeManagementListeners = () => { // Renamed function
                if (addRepresentativeButton) { // Updated ID
                    addRepresentativeButton.addEventListener('click', () => { // Updated ID
                        showRepresentativeForm(); // Updated function call
                    });
                }

                if (backFromManagementButton) { // Updated ID
                    backFromManagementButton.addEventListener('click', () => { // Updated ID
                        goBackToRepresentatives(); // Updated function call
                    });
                }

                if (representativeManagementList) { // Updated ID
                    representativeManagementList.addEventListener('click', (event) => { // Updated ID
                        const editButton = event.target.closest('.edit-representative-button'); // Updated class
                        const deleteButton = event.target.closest('.delete-representative-button'); // Updated class

                        if (editButton) {
                            const key = editButton.dataset.key;
                            const representativeToEdit = getRepresentativeByKey(key); // Updated function call
                            if (representativeToEdit) {
                                showRepresentativeForm(representativeToEdit); // Updated function call
                            } else {
                                announce(`Error: Representative with key ${key} not found.`); // Updated text
                            }
                        } else if (deleteButton) {
                            const key = deleteButton.dataset.key;
                            if (confirm('Are you sure you want to delete this representative?')) { // Updated text
                                deleteRepresentative(key); // Updated function call
                            }
                        }
                    });
                }

                if (representativeForm) { // Updated ID
                    representativeForm.addEventListener('submit', (event) => { // Updated ID
                        event.preventDefault();

                        const formData = {
                            key: formRepresentativeKey ? formRepresentativeKey.value : '', // Updated ID
                            name: formRepresentativeName ? formRepresentativeName.value.trim() : '', // Updated ID
                            instruction: formRepresentativeInstruction ? formRepresentativeInstruction.value.trim() : '', // Updated ID
                            types: formRepresentativeTypes ? formRepresentativeTypes.value.trim() : '', // Updated ID
                            categories: formRepresentativeCategories ? formRepresentativeCategories.value.trim() : '' // Updated ID
                        };

                        const success = saveRepresentative(formData); // Updated function call

                        if (success) {
                            hideRepresentativeForm(); // Updated function call
                        }
                    });
                }

                if (cancelFormButton) {
                    cancelFormButton.addEventListener('click', hideRepresentativeForm); // Updated function call
                }

                if (representativeFormModal) { // Updated ID
                    representativeFormModal.addEventListener('click', (event) => { // Updated ID
                        // Close modal if clicking outside the modal content
                        if (event.target === representativeFormModal) { // Updated ID
                            hideRepresentativeForm(); // Updated function call
                        }
                    });
                }
            };


            // --- Main Application Logic ---

            // Ensure ARIA status element is created early
            createAriaStatusElement();

            // Load theme preference immediately
            const savedTheme = loadTheme();
            applyTheme(savedTheme || 'light');

            // Load representatives from storage (or defaults)
            loadRepresentatives(); // Updated function call

            // Load other general state (filters)
            loadState();

            // Update filter checkboxes visually based on loaded state
            updateFilterCheckboxes();

            // Attempt to load active chat state. If successful, go to chat; otherwise, go to representative selection
            const chatLoaded = loadActiveChatState();

            if (chatLoaded) {
                // Set the correct representative name in the header if a chat was loaded
                if (appState.selectedRepresentative && currentRepresentativeSpan) { // Updated state property and ID
                    currentRepresentativeSpan.textContent = appState.selectedRepresentative.name; // Updated state property
                }
                showView('chat');
            } else {
                showView('representative-selection'); // Updated view name
            }


            // --- Event Listeners ---

            // Dark Mode Toggle
            if (darkModeToggle) {
                darkModeToggle.addEventListener('click', () => {
                    const currentTheme = body.classList.contains('dark-mode') ? 'dark' : 'light';
                    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                    applyTheme(newTheme);
                    saveTheme(newTheme);
                    announce(`Theme switched to ${newTheme} mode.`);
                });
            }

            // Representative Filtering & Search Listeners (Updated IDs)
            const filterOptionsDiv = document.querySelector('#representative-filters .filter-options'); // Updated ID
            if (filterOptionsDiv) {
                filterOptionsDiv.addEventListener('change', handleFilterChange);
            }
            if (representativeSearchInput) representativeSearchInput.addEventListener('input', handleSearchInput); // Updated ID

            // Representative Card Click Listener (using delegation on the grid - Updated IDs/Classes)
            if (representativeGridDiv) { // Updated ID
                representativeGridDiv.addEventListener('click', (event) => { // Updated ID
                    if (appState.currentState !== 'representative-selection') { // Updated state name
                        console.warn("Attempted to select representative while not on selection view."); // Updated text
                        return;
                    }
                    const clickedCard = event.target.closest('.representative-card'); // Updated class
                    if (clickedCard && !clickedCard.disabled) {
                        const representativeKey = clickedCard.dataset.key;
                        const representativeObject = appState.allRepresentativesMutable.find(r => r.key === representativeKey); // Updated state property and variable name
                        if (representativeObject) {
                            startChat(representativeObject); // Updated function call
                        } else {
                            console.warn(`Clicked representative with key ${representativeKey} not found in mutable list.`); // Updated text
                            announce(`Selected representative not found.`); // Updated text
                        }
                    }
                });
            }

            // Chat Input Listeners
            if (sendButton) sendButton.addEventListener('click', sendMessage);
            if (userInput) {
                userInput.addEventListener('keypress', (event) => {
                    if (event.key === 'Enter' && !event.shiftKey) { // Allow Shift+Enter for new line
                        event.preventDefault();
                        if (appState.currentState === 'chat' && !userInput.disabled) {
                            sendMessage();
                        }
                    }
                });
                // Auto-resize textarea
                userInput.addEventListener('input', () => {
                    userInput.style.height = 'auto';
                    userInput.style.height = (userInput.scrollHeight) + 'px';
                });
            }


            // Chat Header Button Listeners (Updated IDs)

            if (backToRepresentativesButton) { // Updated ID
                backToRepresentativesButton.addEventListener('click', goBackToRepresentatives); // Updated function call
            }
            if (clearChatButton) {
                clearChatButton.addEventListener('click', clearChatHistory);
            }

            // Representative Management Button Listener (Updated ID)
            if (manageRepresentativesButton) { // Updated ID
                manageRepresentativesButton.addEventListener('click', showRepresentativeManagementView); // Updated function call
            }

            // Setup Listeners specific to the Representative Management View and Form
            setupRepresentativeManagementListeners(); // Updated function call
        });
    </script>
</body>

</html>